"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-fetch";
exports.ids = ["vendor-chunks/node-fetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\nvar conversions = {};\nmodule.exports = conversions;\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if (x % 1 === 0.5 && (x & 1) === 0) {\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n    return function(V, opts) {\n        if (!opts) opts = {};\n        let x = +V;\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n            return x;\n        }\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n                x += moduloVal;\n            } else if (x === -0) {\n                return 0;\n            }\n        }\n        return x;\n    };\n}\nconversions[\"void\"] = function() {\n    return undefined;\n};\nconversions[\"boolean\"] = function(val) {\n    return !!val;\n};\nconversions[\"byte\"] = createNumberConversion(8, {\n    unsigned: false\n});\nconversions[\"octet\"] = createNumberConversion(8, {\n    unsigned: true\n});\nconversions[\"short\"] = createNumberConversion(16, {\n    unsigned: false\n});\nconversions[\"unsigned short\"] = createNumberConversion(16, {\n    unsigned: true\n});\nconversions[\"long\"] = createNumberConversion(32, {\n    unsigned: false\n});\nconversions[\"unsigned long\"] = createNumberConversion(32, {\n    unsigned: true\n});\nconversions[\"long long\"] = createNumberConversion(32, {\n    unsigned: false,\n    moduloBitLength: 64\n});\nconversions[\"unsigned long long\"] = createNumberConversion(32, {\n    unsigned: true,\n    moduloBitLength: 64\n});\nconversions[\"double\"] = function(V) {\n    const x = +V;\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n    return x;\n};\nconversions[\"unrestricted double\"] = function(V) {\n    const x = +V;\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n    return x;\n};\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\nconversions[\"DOMString\"] = function(V, opts) {\n    if (!opts) opts = {};\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n    return String(V);\n};\nconversions[\"ByteString\"] = function(V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for(let i = 0; (c = x.codePointAt(i)) !== undefined; ++i){\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n    return x;\n};\nconversions[\"USVString\"] = function(V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for(let i = 0; i < n; ++i){\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n    return U.join(\"\");\n};\nconversions[\"Date\"] = function(V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n    return V;\n};\nconversions[\"RegExp\"] = function(V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n    return V;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGNBQWMsQ0FBQztBQUNuQkMsT0FBT0MsT0FBTyxHQUFHRjtBQUVqQixTQUFTRyxLQUFLQyxDQUFDO0lBQ1gsT0FBT0EsSUFBSSxJQUFJLENBQUMsSUFBSTtBQUN4QjtBQUVBLFNBQVNDLFVBQVVELENBQUM7SUFDaEIsNEZBQTRGO0lBQzVGLElBQUksSUFBSyxNQUFPLE9BQU8sQ0FBQ0EsSUFBSSxPQUFPLEdBQUc7UUFDbEMsT0FBT0UsS0FBS0MsS0FBSyxDQUFDSDtJQUN0QixPQUFPO1FBQ0gsT0FBT0UsS0FBS0UsS0FBSyxDQUFDSjtJQUN0QjtBQUNKO0FBRUEsU0FBU0ssdUJBQXVCQyxTQUFTLEVBQUVDLFFBQVE7SUFDL0MsSUFBSSxDQUFDQSxTQUFTQyxRQUFRLEVBQUU7UUFDcEIsRUFBRUY7SUFDTjtJQUNBLE1BQU1HLGFBQWFGLFNBQVNDLFFBQVEsR0FBRyxJQUFJLENBQUNOLEtBQUtRLEdBQUcsQ0FBQyxHQUFHSjtJQUN4RCxNQUFNSyxhQUFhVCxLQUFLUSxHQUFHLENBQUMsR0FBR0osYUFBYTtJQUU1QyxNQUFNTSxZQUFZTCxTQUFTTSxlQUFlLEdBQUdYLEtBQUtRLEdBQUcsQ0FBQyxHQUFHSCxTQUFTTSxlQUFlLElBQUlYLEtBQUtRLEdBQUcsQ0FBQyxHQUFHSjtJQUNqRyxNQUFNUSxjQUFjUCxTQUFTTSxlQUFlLEdBQUdYLEtBQUtRLEdBQUcsQ0FBQyxHQUFHSCxTQUFTTSxlQUFlLEdBQUcsS0FBS1gsS0FBS1EsR0FBRyxDQUFDLEdBQUdKLFlBQVk7SUFFbkgsT0FBTyxTQUFTUyxDQUFDLEVBQUVDLElBQUk7UUFDbkIsSUFBSSxDQUFDQSxNQUFNQSxPQUFPLENBQUM7UUFFbkIsSUFBSWhCLElBQUksQ0FBQ2U7UUFFVCxJQUFJQyxLQUFLQyxZQUFZLEVBQUU7WUFD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LElBQUssQ0FBQyxLQUFLLEtBQUtFLElBQUlDO29CQUN2RCxFQUFFWDtnQkFDTixPQUFPO29CQUNISyxFQUFFRSxJQUFJLENBQUNULE9BQU9VLGFBQWEsQ0FBQztnQkFDaEM7WUFDSjtRQUNKO0lBQ0o7SUFFQSxPQUFPSCxFQUFFTyxJQUFJLENBQUM7QUFDbEI7QUFFQTdDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsU0FBVW1CLENBQUMsRUFBRUMsSUFBSTtJQUNuQyxJQUFJLENBQUVELENBQUFBLGFBQWEyQixJQUFHLEdBQUk7UUFDdEIsTUFBTSxJQUFJdEIsVUFBVTtJQUN4QjtJQUNBLElBQUlFLE1BQU1QLElBQUk7UUFDVixPQUFPUztJQUNYO0lBRUEsT0FBT1Q7QUFDWDtBQUVBbkIsV0FBVyxDQUFDLFNBQVMsR0FBRyxTQUFVbUIsQ0FBQyxFQUFFQyxJQUFJO0lBQ3JDLElBQUksQ0FBRUQsQ0FBQUEsYUFBYTRCLE1BQUssR0FBSTtRQUN4QjVCLElBQUksSUFBSTRCLE9BQU81QjtJQUNuQjtJQUVBLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL25vZGVfbW9kdWxlcy93ZWJpZGwtY29udmVyc2lvbnMvbGliL2luZGV4LmpzP2RiZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb252ZXJzaW9ucyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJzaW9ucztcblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xufVxuXG5mdW5jdGlvbiBldmVuUm91bmQoeCkge1xuICAgIC8vIFJvdW5kIHggdG8gdGhlIG5lYXJlc3QgaW50ZWdlciwgY2hvb3NpbmcgdGhlIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28uXG4gICAgaWYgKCh4ICUgMSkgPT09IDAuNSAmJiAoeCAmIDEpID09PSAwKSB7IC8vIFtldmVuIG51bWJlcl0uNTsgcm91bmQgZG93biAoaS5lLiBmbG9vcilcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKGJpdExlbmd0aCwgdHlwZU9wdHMpIHtcbiAgICBpZiAoIXR5cGVPcHRzLnVuc2lnbmVkKSB7XG4gICAgICAgIC0tYml0TGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBsb3dlckJvdW5kID0gdHlwZU9wdHMudW5zaWduZWQgPyAwIDogLU1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gICAgY29uc3QgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxO1xuXG4gICAgY29uc3QgbW9kdWxvVmFsID0gdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoID8gTWF0aC5wb3coMiwgdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoKSA6IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gICAgY29uc3QgbW9kdWxvQm91bmQgPSB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggPyBNYXRoLnBvdygyLCB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggLSAxKSA6IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKFYsIG9wdHMpIHtcbiAgICAgICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG5cbiAgICAgICAgbGV0IHggPSArVjtcblxuICAgICAgICBpZiAob3B0cy5lbmZvcmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZpbml0ZSBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSBzaWduKHgpICogTWF0aC5mbG9vcihNYXRoLmFicyh4KSk7XG4gICAgICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGluIGJ5dGUgcmFuZ2VcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTih4KSAmJiBvcHRzLmNsYW1wKSB7XG4gICAgICAgICAgICB4ID0gZXZlblJvdW5kKHgpO1xuXG4gICAgICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQpIHggPSBsb3dlckJvdW5kO1xuICAgICAgICAgICAgaWYgKHggPiB1cHBlckJvdW5kKSB4ID0gdXBwZXJCb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gc2lnbih4KSAqIE1hdGguZmxvb3IoTWF0aC5hYnMoeCkpO1xuICAgICAgICB4ID0geCAlIG1vZHVsb1ZhbDtcblxuICAgICAgICBpZiAoIXR5cGVPcHRzLnVuc2lnbmVkICYmIHggPj0gbW9kdWxvQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB4IC0gbW9kdWxvVmFsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVPcHRzLnVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgICAgeCArPSBtb2R1bG9WYWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHggPT09IC0wKSB7IC8vIGRvbid0IHJldHVybiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxufVxuXG5jb252ZXJzaW9uc1tcInZvaWRcIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNvbnZlcnNpb25zW1wiYm9vbGVhblwiXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gISF2YWw7XG59O1xuXG5jb252ZXJzaW9uc1tcImJ5dGVcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xuY29udmVyc2lvbnNbXCJvY3RldFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oOCwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcblxuY29udmVyc2lvbnNbXCJzaG9ydFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMTYsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xuY29udmVyc2lvbnNbXCJ1bnNpZ25lZCBzaG9ydFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMTYsIHsgdW5zaWduZWQ6IHRydWUgfSk7XG5cbmNvbnZlcnNpb25zW1wibG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xuY29udmVyc2lvbnNbXCJ1bnNpZ25lZCBsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcblxuY29udmVyc2lvbnNbXCJsb25nIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiBmYWxzZSwgbW9kdWxvQml0TGVuZ3RoOiA2NCB9KTtcbmNvbnZlcnNpb25zW1widW5zaWduZWQgbG9uZyBsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogdHJ1ZSwgbW9kdWxvQml0TGVuZ3RoOiA2NCB9KTtcblxuY29udmVyc2lvbnNbXCJkb3VibGVcIl0gPSBmdW5jdGlvbiAoVikge1xuICAgIGNvbnN0IHggPSArVjtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBmaW5pdGUgZmxvYXRpbmctcG9pbnQgdmFsdWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG59O1xuXG5jb252ZXJzaW9uc1tcInVucmVzdHJpY3RlZCBkb3VibGVcIl0gPSBmdW5jdGlvbiAoVikge1xuICAgIGNvbnN0IHggPSArVjtcblxuICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgTmFOXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB4O1xufTtcblxuLy8gbm90IHF1aXRlIHZhbGlkLCBidXQgZ29vZCBlbm91Z2ggZm9yIEpTXG5jb252ZXJzaW9uc1tcImZsb2F0XCJdID0gY29udmVyc2lvbnNbXCJkb3VibGVcIl07XG5jb252ZXJzaW9uc1tcInVucmVzdHJpY3RlZCBmbG9hdFwiXSA9IGNvbnZlcnNpb25zW1widW5yZXN0cmljdGVkIGRvdWJsZVwiXTtcblxuY29udmVyc2lvbnNbXCJET01TdHJpbmdcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG4gICAgaWYgKG9wdHMudHJlYXROdWxsQXNFbXB0eVN0cmluZyAmJiBWID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcoVik7XG59O1xuXG5jb252ZXJzaW9uc1tcIkJ5dGVTdHJpbmdcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xuICAgIGNvbnN0IHggPSBTdHJpbmcoVik7XG4gICAgbGV0IGMgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IChjID0geC5jb2RlUG9pbnRBdChpKSkgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIGlmIChjID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgdmFsaWQgYnl0ZXN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4O1xufTtcblxuY29udmVyc2lvbnNbXCJVU1ZTdHJpbmdcIl0gPSBmdW5jdGlvbiAoVikge1xuICAgIGNvbnN0IFMgPSBTdHJpbmcoVik7XG4gICAgY29uc3QgbiA9IFMubGVuZ3RoO1xuICAgIGNvbnN0IFUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBjID0gUy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID4gMHhERkZGKSB7XG4gICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoYykpO1xuICAgICAgICB9IGVsc2UgaWYgKDB4REMwMCA8PSBjICYmIGMgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBTLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmICgweERDMDAgPD0gZCAmJiBkIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gYyAmIDB4M0ZGO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gZCAmIDB4M0ZGO1xuICAgICAgICAgICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoKDIgPDwgMTUpICsgKDIgPDwgOSkgKiBhICsgYikpO1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBVLmpvaW4oJycpO1xufTtcblxuY29udmVyc2lvbnNbXCJEYXRlXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcbiAgICBpZiAoIShWIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIERhdGUgb2JqZWN0XCIpO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oVikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gVjtcbn07XG5cbmNvbnZlcnNpb25zW1wiUmVnRXhwXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcbiAgICBpZiAoIShWIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICBWID0gbmV3IFJlZ0V4cChWKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVjtcbn07XG4iXSwibmFtZXMiOlsiY29udmVyc2lvbnMiLCJtb2R1bGUiLCJleHBvcnRzIiwic2lnbiIsIngiLCJldmVuUm91bmQiLCJNYXRoIiwiZmxvb3IiLCJyb3VuZCIsImNyZWF0ZU51bWJlckNvbnZlcnNpb24iLCJiaXRMZW5ndGgiLCJ0eXBlT3B0cyIsInVuc2lnbmVkIiwibG93ZXJCb3VuZCIsInBvdyIsInVwcGVyQm91bmQiLCJtb2R1bG9WYWwiLCJtb2R1bG9CaXRMZW5ndGgiLCJtb2R1bG9Cb3VuZCIsIlYiLCJvcHRzIiwiZW5mb3JjZVJhbmdlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJUeXBlRXJyb3IiLCJhYnMiLCJpc05hTiIsImNsYW1wIiwidW5kZWZpbmVkIiwidmFsIiwidHJlYXROdWxsQXNFbXB0eVN0cmluZyIsIlN0cmluZyIsImMiLCJpIiwiY29kZVBvaW50QXQiLCJTIiwibiIsImxlbmd0aCIsIlUiLCJjaGFyQ29kZUF0IiwicHVzaCIsImZyb21Db2RlUG9pbnQiLCJkIiwiYSIsImIiLCJqb2luIiwiRGF0ZSIsIlJlZ0V4cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst usm = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\");\nexports.implementation = class URLImpl {\n    constructor(constructorArgs){\n        const url = constructorArgs[0];\n        const base = constructorArgs[1];\n        let parsedBase = null;\n        if (base !== undefined) {\n            parsedBase = usm.basicURLParse(base);\n            if (parsedBase === \"failure\") {\n                throw new TypeError(\"Invalid base URL\");\n            }\n        }\n        const parsedURL = usm.basicURLParse(url, {\n            baseURL: parsedBase\n        });\n        if (parsedURL === \"failure\") {\n            throw new TypeError(\"Invalid URL\");\n        }\n        this._url = parsedURL;\n    // TODO: query stuff\n    }\n    get href() {\n        return usm.serializeURL(this._url);\n    }\n    set href(v) {\n        const parsedURL = usm.basicURLParse(v);\n        if (parsedURL === \"failure\") {\n            throw new TypeError(\"Invalid URL\");\n        }\n        this._url = parsedURL;\n    }\n    get origin() {\n        return usm.serializeURLOrigin(this._url);\n    }\n    get protocol() {\n        return this._url.scheme + \":\";\n    }\n    set protocol(v) {\n        usm.basicURLParse(v + \":\", {\n            url: this._url,\n            stateOverride: \"scheme start\"\n        });\n    }\n    get username() {\n        return this._url.username;\n    }\n    set username(v) {\n        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n            return;\n        }\n        usm.setTheUsername(this._url, v);\n    }\n    get password() {\n        return this._url.password;\n    }\n    set password(v) {\n        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n            return;\n        }\n        usm.setThePassword(this._url, v);\n    }\n    get host() {\n        const url = this._url;\n        if (url.host === null) {\n            return \"\";\n        }\n        if (url.port === null) {\n            return usm.serializeHost(url.host);\n        }\n        return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n    }\n    set host(v) {\n        if (this._url.cannotBeABaseURL) {\n            return;\n        }\n        usm.basicURLParse(v, {\n            url: this._url,\n            stateOverride: \"host\"\n        });\n    }\n    get hostname() {\n        if (this._url.host === null) {\n            return \"\";\n        }\n        return usm.serializeHost(this._url.host);\n    }\n    set hostname(v) {\n        if (this._url.cannotBeABaseURL) {\n            return;\n        }\n        usm.basicURLParse(v, {\n            url: this._url,\n            stateOverride: \"hostname\"\n        });\n    }\n    get port() {\n        if (this._url.port === null) {\n            return \"\";\n        }\n        return usm.serializeInteger(this._url.port);\n    }\n    set port(v) {\n        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n            return;\n        }\n        if (v === \"\") {\n            this._url.port = null;\n        } else {\n            usm.basicURLParse(v, {\n                url: this._url,\n                stateOverride: \"port\"\n            });\n        }\n    }\n    get pathname() {\n        if (this._url.cannotBeABaseURL) {\n            return this._url.path[0];\n        }\n        if (this._url.path.length === 0) {\n            return \"\";\n        }\n        return \"/\" + this._url.path.join(\"/\");\n    }\n    set pathname(v) {\n        if (this._url.cannotBeABaseURL) {\n            return;\n        }\n        this._url.path = [];\n        usm.basicURLParse(v, {\n            url: this._url,\n            stateOverride: \"path start\"\n        });\n    }\n    get search() {\n        if (this._url.query === null || this._url.query === \"\") {\n            return \"\";\n        }\n        return \"?\" + this._url.query;\n    }\n    set search(v) {\n        // TODO: query stuff\n        const url = this._url;\n        if (v === \"\") {\n            url.query = null;\n            return;\n        }\n        const input = v[0] === \"?\" ? v.substring(1) : v;\n        url.query = \"\";\n        usm.basicURLParse(input, {\n            url,\n            stateOverride: \"query\"\n        });\n    }\n    get hash() {\n        if (this._url.fragment === null || this._url.fragment === \"\") {\n            return \"\";\n        }\n        return \"#\" + this._url.fragment;\n    }\n    set hash(v) {\n        if (v === \"\") {\n            this._url.fragment = null;\n            return;\n        }\n        const input = v[0] === \"#\" ? v.substring(1) : v;\n        this._url.fragment = \"\";\n        usm.basicURLParse(input, {\n            url: this._url,\n            stateOverride: \"fragment\"\n        });\n    }\n    toJSON() {\n        return this.href;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvVVJMLWltcGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixNQUFNQSxNQUFNQyxtQkFBT0EsQ0FBQyw2R0FBcUI7QUFFekNDLHNCQUFzQixHQUFHLE1BQU1FO0lBQzdCQyxZQUFZQyxlQUFlLENBQUU7UUFDM0IsTUFBTUMsTUFBTUQsZUFBZSxDQUFDLEVBQUU7UUFDOUIsTUFBTUUsT0FBT0YsZUFBZSxDQUFDLEVBQUU7UUFFL0IsSUFBSUcsYUFBYTtRQUNqQixJQUFJRCxTQUFTRSxXQUFXO1lBQ3RCRCxhQUFhVCxJQUFJVyxhQUFhLENBQUNIO1lBQy9CLElBQUlDLGVBQWUsV0FBVztnQkFDNUIsTUFBTSxJQUFJRyxVQUFVO1lBQ3RCO1FBQ0Y7UUFFQSxNQUFNQyxZQUFZYixJQUFJVyxhQUFhLENBQUNKLEtBQUs7WUFBRU8sU0FBU0w7UUFBVztRQUMvRCxJQUFJSSxjQUFjLFdBQVc7WUFDM0IsTUFBTSxJQUFJRCxVQUFVO1FBQ3RCO1FBRUEsSUFBSSxDQUFDRyxJQUFJLEdBQUdGO0lBRVosb0JBQW9CO0lBQ3RCO0lBRUEsSUFBSUcsT0FBTztRQUNULE9BQU9oQixJQUFJaUIsWUFBWSxDQUFDLElBQUksQ0FBQ0YsSUFBSTtJQUNuQztJQUVBLElBQUlDLEtBQUtFLENBQUMsRUFBRTtRQUNWLE1BQU1MLFlBQVliLElBQUlXLGFBQWEsQ0FBQ087UUFDcEMsSUFBSUwsY0FBYyxXQUFXO1lBQzNCLE1BQU0sSUFBSUQsVUFBVTtRQUN0QjtRQUVBLElBQUksQ0FBQ0csSUFBSSxHQUFHRjtJQUNkO0lBRUEsSUFBSU0sU0FBUztRQUNYLE9BQU9uQixJQUFJb0Isa0JBQWtCLENBQUMsSUFBSSxDQUFDTCxJQUFJO0lBQ3pDO0lBRUEsSUFBSU0sV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDTixJQUFJLENBQUNPLE1BQU0sR0FBRztJQUM1QjtJQUVBLElBQUlELFNBQVNILENB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UUFBUTtJQUNqQztJQUVBLElBQUlELEtBQUt6QixDQUFDLEVBQUU7UUFDVixJQUFJQSxNQUFNLElBQUk7WUFDWixJQUFJLENBQUNILElBQUksQ0FBQzZCLFFBQVEsR0FBRztZQUNyQjtRQUNGO1FBRUEsTUFBTUgsUUFBUXZCLENBQUMsQ0FBQyxFQUFFLEtBQUssTUFBTUEsRUFBRXdCLFNBQVMsQ0FBQyxLQUFLeEI7UUFDOUMsSUFBSSxDQUFDSCxJQUFJLENBQUM2QixRQUFRLEdBQUc7UUFDckI1QyxJQUFJVyxhQUFhLENBQUM4QixPQUFPO1lBQUVsQyxLQUFLLElBQUksQ0FBQ1EsSUFBSTtZQUFFUSxlQUFlO1FBQVc7SUFDdkU7SUFFQXNCLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQzdCLElBQUk7SUFDbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvbm9kZV9tb2R1bGVzL3doYXR3Zy11cmwvbGliL1VSTC1pbXBsLmpzP2U2YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1c20gPSByZXF1aXJlKFwiLi91cmwtc3RhdGUtbWFjaGluZVwiKTtcblxuZXhwb3J0cy5pbXBsZW1lbnRhdGlvbiA9IGNsYXNzIFVSTEltcGwge1xuICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3RvckFyZ3MpIHtcbiAgICBjb25zdCB1cmwgPSBjb25zdHJ1Y3RvckFyZ3NbMF07XG4gICAgY29uc3QgYmFzZSA9IGNvbnN0cnVjdG9yQXJnc1sxXTtcblxuICAgIGxldCBwYXJzZWRCYXNlID0gbnVsbDtcbiAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWRCYXNlID0gdXNtLmJhc2ljVVJMUGFyc2UoYmFzZSk7XG4gICAgICBpZiAocGFyc2VkQmFzZSA9PT0gXCJmYWlsdXJlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYmFzZSBVUkxcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkVVJMID0gdXNtLmJhc2ljVVJMUGFyc2UodXJsLCB7IGJhc2VVUkw6IHBhcnNlZEJhc2UgfSk7XG4gICAgaWYgKHBhcnNlZFVSTCA9PT0gXCJmYWlsdXJlXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFVSTFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cmwgPSBwYXJzZWRVUkw7XG5cbiAgICAvLyBUT0RPOiBxdWVyeSBzdHVmZlxuICB9XG5cbiAgZ2V0IGhyZWYoKSB7XG4gICAgcmV0dXJuIHVzbS5zZXJpYWxpemVVUkwodGhpcy5fdXJsKTtcbiAgfVxuXG4gIHNldCBocmVmKHYpIHtcbiAgICBjb25zdCBwYXJzZWRVUkwgPSB1c20uYmFzaWNVUkxQYXJzZSh2KTtcbiAgICBpZiAocGFyc2VkVVJMID09PSBcImZhaWx1cmVcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgVVJMXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX3VybCA9IHBhcnNlZFVSTDtcbiAgfVxuXG4gIGdldCBvcmlnaW4oKSB7XG4gICAgcmV0dXJuIHVzbS5zZXJpYWxpemVVUkxPcmlnaW4odGhpcy5fdXJsKTtcbiAgfVxuXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsLnNjaGVtZSArIFwiOlwiO1xuICB9XG5cbiAgc2V0IHByb3RvY29sKHYpIHtcbiAgICB1c20uYmFzaWNVUkxQYXJzZSh2ICsgXCI6XCIsIHsgdXJsOiB0aGlzLl91cmwsIHN0YXRlT3ZlcnJpZGU6IFwic2NoZW1lIHN0YXJ0XCIgfSk7XG4gIH1cblxuICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybC51c2VybmFtZTtcbiAgfVxuXG4gIHNldCB1c2VybmFtZSh2KSB7XG4gICAgaWYgKHVzbS5jYW5ub3RIYXZlQVVzZXJuYW1lUGFzc3dvcmRQb3J0KHRoaXMuX3VybCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1c20uc2V0VGhlVXNlcm5hbWUodGhpcy5fdXJsLCB2KTtcbiAgfVxuXG4gIGdldCBwYXNzd29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsLnBhc3N3b3JkO1xuICB9XG5cbiAgc2V0IHBhc3N3b3JkKHYpIHtcbiAgICBpZiAodXNtLmNhbm5vdEhhdmVBVXNlcm5hbWVQYXNzd29yZFBvcnQodGhpcy5fdXJsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVzbS5zZXRUaGVQYXNzd29yZCh0aGlzLl91cmwsIHYpO1xuICB9XG5cbiAgZ2V0IGhvc3QoKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5fdXJsO1xuXG4gICAgaWYgKHVybC5ob3N0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAodXJsLnBvcnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1c20uc2VyaWFsaXplSG9zdCh1cmwuaG9zdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzbS5zZXJpYWxpemVIb3N0KHVybC5ob3N0KSArIFwiOlwiICsgdXNtLnNlcmlhbGl6ZUludGVnZXIodXJsLnBvcnQpO1xuICB9XG5cbiAgc2V0IGhvc3Qodikge1xuICAgIGlmICh0aGlzLl91cmwuY2Fubm90QmVBQmFzZVVSTCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVzbS5iYXNpY1VSTFBhcnNlKHYsIHsgdXJsOiB0aGlzLl91cmwsIHN0YXRlT3ZlcnJpZGU6IFwiaG9zdFwiIH0pO1xuICB9XG5cbiAgZ2V0IGhvc3RuYW1lKCkge1xuICAgIGlmICh0aGlzLl91cmwuaG9zdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzbS5zZXJpYWxpemVIb3N0KHRoaXMuX3VybC5ob3N0KTtcbiAgfVxuXG4gIHNldCBob3N0bmFtZSh2KSB7XG4gICAgaWYgKHRoaXMuX3VybC5jYW5ub3RCZUFCYXNlVVJMKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXNtLmJhc2ljVVJMUGFyc2UodiwgeyB1cmw6IHRoaXMuX3VybCwgc3RhdGVPdmVycmlkZTogXCJob3N0bmFtZVwiIH0pO1xuICB9XG5cbiAgZ2V0IHBvcnQoKSB7XG4gICAgaWYgKHRoaXMuX3VybC5wb3J0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXNtLnNlcmlhbGl6ZUludGVnZXIodGhpcy5fdXJsLnBvcnQpO1xuICB9XG5cbiAgc2V0IHBvcnQodikge1xuICAgIGlmICh1c20uY2Fubm90SGF2ZUFVc2VybmFtZVBhc3N3b3JkUG9ydCh0aGlzLl91cmwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuX3VybC5wb3J0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdXNtLmJhc2ljVVJMUGFyc2UodiwgeyB1cmw6IHRoaXMuX3VybCwgc3RhdGVPdmVycmlkZTogXCJwb3J0XCIgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhdGhuYW1lKCkge1xuICAgIGlmICh0aGlzLl91cmwuY2Fubm90QmVBQmFzZVVSTCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybC5wYXRoWzBdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl91cmwucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBcIi9cIiArIHRoaXMuX3VybC5wYXRoLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgc2V0IHBhdGhuYW1lKHYpIHtcbiAgICBpZiAodGhpcy5fdXJsLmNhbm5vdEJlQUJhc2VVUkwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cmwucGF0aCA9IFtdO1xuICAgIHVzbS5iYXNpY1VSTFBhcnNlKHYsIHsgdXJsOiB0aGlzLl91cmwsIHN0YXRlT3ZlcnJpZGU6IFwicGF0aCBzdGFydFwiIH0pO1xuICB9XG5cbiAgZ2V0IHNlYXJjaCgpIHtcbiAgICBpZiAodGhpcy5fdXJsLnF1ZXJ5ID09PSBudWxsIHx8IHRoaXMuX3VybC5xdWVyeSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiP1wiICsgdGhpcy5fdXJsLnF1ZXJ5O1xuICB9XG5cbiAgc2V0IHNlYXJjaCh2KSB7XG4gICAgLy8gVE9ETzogcXVlcnkgc3R1ZmZcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuX3VybDtcblxuICAgIGlmICh2ID09PSBcIlwiKSB7XG4gICAgICB1cmwucXVlcnkgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gdlswXSA9PT0gXCI/XCIgPyB2LnN1YnN0cmluZygxKSA6IHY7XG4gICAgdXJsLnF1ZXJ5ID0gXCJcIjtcbiAgICB1c20uYmFzaWNVUkxQYXJzZShpbnB1dCwgeyB1cmwsIHN0YXRlT3ZlcnJpZGU6IFwicXVlcnlcIiB9KTtcbiAgfVxuXG4gIGdldCBoYXNoKCkge1xuICAgIGlmICh0aGlzLl91cmwuZnJhZ21lbnQgPT09IG51bGwgfHwgdGhpcy5fdXJsLmZyYWdtZW50ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCIjXCIgKyB0aGlzLl91cmwuZnJhZ21lbnQ7XG4gIH1cblxuICBzZXQgaGFzaCh2KSB7XG4gICAgaWYgKHYgPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuX3VybC5mcmFnbWVudCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQgPSB2WzBdID09PSBcIiNcIiA/IHYuc3Vic3RyaW5nKDEpIDogdjtcbiAgICB0aGlzLl91cmwuZnJhZ21lbnQgPSBcIlwiO1xuICAgIHVzbS5iYXNpY1VSTFBhcnNlKGlucHV0LCB7IHVybDogdGhpcy5fdXJsLCBzdGF0ZU92ZXJyaWRlOiBcImZyYWdtZW50XCIgfSk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJ1c20iLCJyZXF1aXJlIiwiZXhwb3J0cyIsImltcGxlbWVudGF0aW9uIiwiVVJMSW1wbCIsImNvbnN0cnVjdG9yIiwiY29uc3RydWN0b3JBcmdzIiwidXJsIiwiYmFzZSIsInBhcnNlZEJhc2UiLCJ1bmRlZmluZWQiLCJiYXNpY1VSTFBhcnNlIiwiVHlwZUVycm9yIiwicGFyc2VkVVJMIiwiYmFzZVVSTCIsIl91cmwiLCJocmVmIiwic2VyaWFsaXplVVJMIiwidiIsIm9yaWdpbiIsInNlcmlhbGl6ZVVSTE9yaWdpbiIsInByb3RvY29sIiwic2NoZW1lIiwic3RhdGVPdmVycmlkZSIsInVzZXJuYW1lIiwiY2Fubm90SGF2ZUFVc2VybmFtZVBhc3N3b3JkUG9ydCIsInNldFRoZVVzZXJuYW1lIiwicGFzc3dvcmQiLCJzZXRUaGVQYXNzd29yZCIsImhvc3QiLCJwb3J0Iiwic2VyaWFsaXplSG9zdCIsInNlcmlhbGl6ZUludGVnZXIiLCJjYW5ub3RCZUFCYXNlVVJMIiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInBhdGgiLCJsZW5ndGgiLCJqb2luIiwic2VhcmNoIiwicXVlcnkiLCJpbnB1dCIsInN1YnN0cmluZyIsImhhc2giLCJmcmFnbWVudCIsInRvSlNPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst conversions = __webpack_require__(/*! webidl-conversions */ \"(ssr)/./node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js\");\nconst utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js\");\nconst Impl = __webpack_require__(/*! .//URL-impl.js */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js\");\nconst impl = utils.implSymbol;\nfunction URL(url) {\n    if (!this || this[impl] || !(this instanceof URL)) {\n        throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n    }\n    if (arguments.length < 1) {\n        throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n    }\n    const args = [];\n    for(let i = 0; i < arguments.length && i < 2; ++i){\n        args[i] = arguments[i];\n    }\n    args[0] = conversions[\"USVString\"](args[0]);\n    if (args[1] !== undefined) {\n        args[1] = conversions[\"USVString\"](args[1]);\n    }\n    module.exports.setup(this, args);\n}\nURL.prototype.toJSON = function toJSON() {\n    if (!this || !module.exports.is(this)) {\n        throw new TypeError(\"Illegal invocation\");\n    }\n    const args = [];\n    for(let i = 0; i < arguments.length && i < 0; ++i){\n        args[i] = arguments[i];\n    }\n    return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n    get () {\n        return this[impl].href;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].href = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nURL.prototype.toString = function() {\n    if (!this || !module.exports.is(this)) {\n        throw new TypeError(\"Illegal invocation\");\n    }\n    return this.href;\n};\nObject.defineProperty(URL.prototype, \"origin\", {\n    get () {\n        return this[impl].origin;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"protocol\", {\n    get () {\n        return this[impl].protocol;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].protocol = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"username\", {\n    get () {\n        return this[impl].username;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].username = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"password\", {\n    get () {\n        return this[impl].password;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].password = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"host\", {\n    get () {\n        return this[impl].host;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].host = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"hostname\", {\n    get () {\n        return this[impl].hostname;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].hostname = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"port\", {\n    get () {\n        return this[impl].port;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].port = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"pathname\", {\n    get () {\n        return this[impl].pathname;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].pathname = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"search\", {\n    get () {\n        return this[impl].search;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].search = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nObject.defineProperty(URL.prototype, \"hash\", {\n    get () {\n        return this[impl].hash;\n    },\n    set (V) {\n        V = conversions[\"USVString\"](V);\n        this[impl].hash = V;\n    },\n    enumerable: true,\n    configurable: true\n});\nmodule.exports = {\n    is (obj) {\n        return !!obj && obj[impl] instanceof Impl.implementation;\n    },\n    create (constructorArgs, privateData) {\n        let obj = Object.create(URL.prototype);\n        this.setup(obj, constructorArgs, privateData);\n        return obj;\n    },\n    setup (obj, constructorArgs, privateData) {\n        if (!privateData) privateData = {};\n        privateData.wrapper = obj;\n        obj[impl] = new Impl.implementation(constructorArgs, privateData);\n        obj[impl][utils.wrapperSymbol] = obj;\n    },\n    interface: URL,\n    expose: {\n        Window: {\n            URL: URL\n        },\n        Worker: {\n            URL: URL\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvVVJMLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsTUFBTUEsY0FBY0MsbUJBQU9BLENBQUMsd0dBQW9CO0FBQ2hELE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLHdGQUFZO0FBQ2xDLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDLCtGQUFnQjtBQUVyQyxNQUFNRyxPQUFPRixNQUFNRyxVQUFVO0FBRTdCLFNBQVNDLElBQUlDLEdBQUc7SUFDZCxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQ0gsS0FBSyxJQUFJLENBQUUsS0FBSSxZQUFZRSxHQUFFLEdBQUk7UUFDakQsTUFBTSxJQUFJRSxVQUFVO0lBQ3RCO0lBQ0EsSUFBSUMsVUFBVUMsTUFBTSxHQUFHLEdBQUc7UUFDeEIsTUFBTSxJQUFJRixVQUFVLDhEQUE4REMsVUFBVUMsTUFBTSxHQUFHO0lBQ3ZHO0lBQ0EsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFVBQVVDLE1BQU0sSUFBSUUsSUFBSSxHQUFHLEVBQUVBLEVBQUc7UUFDbERELElBQUksQ0FBQ0MsRUFBRSxHQUFHSCxTQUFTLENBQUNHLEVBQUU7SUFDeEI7SUFDQUQsSUFBSSxDQUFDLEVBQUUsR0FBR1gsV0FBVyxDQUFDLFlBQVksQ0FBQ1csSUFBSSxDQUFDLEVBQUU7SUFDMUMsSUFBSUEsSUFBSSxDQUFDLEVBQUUsS0FBS0UsV0FBVztRQUMzQkYsSUFBSSxDQUFDLEVBQUUsR0FBR1gsV0FBVyxDQUFDLFlBQVksQ0FBQ1csSUFBSSxDQUFDLEVBQUU7SUFDMUM7SUFFQUcsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxFQUFFTDtBQUM3QjtBQUVBTCxJQUFJVyxTQUFTLENBQUNDLE1BQU0sR0FBRyxTQUFTQTtJQUM5QixJQUFJLENBQUMsSUFBSSxJQUFJLENBQUNKLE9BQU9DLE9BQU8sQ0FB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LElBQUkxQixXQUFXLENBQUMsWUFBWSxDQUFDMEI7UUFDN0IsSUFBSSxDQUFDdEIsS0FBSyxDQUFDbUMsSUFBSSxHQUFHYjtJQUNwQjtJQUNBQyxZQUFZO0lBQ1pDLGNBQWM7QUFDaEI7QUFHQWQsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZJLElBQUdxQixHQUFHO1FBQ0osT0FBTyxDQUFDLENBQUNBLE9BQU9BLEdBQUcsQ0FBQ3BDLEtBQUssWUFBWUQsS0FBS3NDLGNBQWM7SUFDMUQ7SUFDQUMsUUFBT0MsZUFBZSxFQUFFQyxXQUFXO1FBQ2pDLElBQUlKLE1BQU1uQixPQUFPcUIsTUFBTSxDQUFDcEMsSUFBSVcsU0FBUztRQUNyQyxJQUFJLENBQUNELEtBQUssQ0FBQ3dCLEtBQUtHLGlCQUFpQkM7UUFDakMsT0FBT0o7SUFDVDtJQUNBeEIsT0FBTXdCLEdBQUcsRUFBRUcsZUFBZSxFQUFFQyxXQUFXO1FBQ3JDLElBQUksQ0FBQ0EsYUFBYUEsY0FBYyxDQUFDO1FBQ2pDQSxZQUFZQyxPQUFPLEdBQUdMO1FBRXRCQSxHQUFHLENBQUNwQyxLQUFLLEdBQUcsSUFBSUQsS0FBS3NDLGNBQWMsQ0FBQ0UsaUJBQWlCQztRQUNyREosR0FBRyxDQUFDcEMsS0FBSyxDQUFDRixNQUFNNEMsYUFBYSxDQUFDLEdBQUdOO0lBQ25DO0lBQ0FPLFdBQVd6QztJQUNYMEMsUUFBUTtRQUNOQyxRQUFRO1lBQUUzQyxLQUFLQTtRQUFJO1FBQ25CNEMsUUFBUTtZQUFFNUMsS0FBS0E7UUFBSTtJQUNyQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvVVJMLmpzPzM5NmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGNvbnZlcnNpb25zID0gcmVxdWlyZShcIndlYmlkbC1jb252ZXJzaW9uc1wiKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBJbXBsID0gcmVxdWlyZShcIi4vL1VSTC1pbXBsLmpzXCIpO1xuXG5jb25zdCBpbXBsID0gdXRpbHMuaW1wbFN5bWJvbDtcblxuZnVuY3Rpb24gVVJMKHVybCkge1xuICBpZiAoIXRoaXMgfHwgdGhpc1tpbXBsXSB8fCAhKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1VSTCc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnVVJMJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgXCIgKyBhcmd1bWVudHMubGVuZ3RoICsgXCIgcHJlc2VudC5cIik7XG4gIH1cbiAgY29uc3QgYXJncyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgaSA8IDI7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgYXJnc1swXSA9IGNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdKGFyZ3NbMF0pO1xuICBpZiAoYXJnc1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gIGFyZ3NbMV0gPSBjb252ZXJzaW9uc1tcIlVTVlN0cmluZ1wiXShhcmdzWzFdKTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzLnNldHVwKHRoaXMsIGFyZ3MpO1xufVxuXG5VUkwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzIHx8ICFtb2R1bGUuZXhwb3J0cy5pcyh0aGlzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gIH1cbiAgY29uc3QgYXJncyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgaSA8IDA7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgcmV0dXJuIHRoaXNbaW1wbF0udG9KU09OLmFwcGx5KHRoaXNbaW1wbF0sIGFyZ3MpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkwucHJvdG90eXBlLCBcImhyZWZcIiwge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNbaW1wbF0uaHJlZjtcbiAgfSxcbiAgc2V0KFYpIHtcbiAgICBWID0gY29udmVyc2lvbnNbXCJVU1ZTdHJpbmdcIl0oVik7XG4gICAgdGhpc1tpbXBsXS5ocmVmID0gVjtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuVVJMLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzIHx8ICFtb2R1bGUuZXhwb3J0cy5pcyh0aGlzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaHJlZjtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkwucHJvdG90eXBlLCBcIm9yaWdpblwiLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpc1tpbXBsXS5vcmlnaW47XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkwucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2ltcGxdLnByb3RvY29sO1xuICB9LFxuICBzZXQoVikge1xuICAgIFYgPSBjb252ZXJzaW9uc1tcIlVTVlN0cmluZ1wiXShWKTtcbiAgICB0aGlzW2ltcGxdLnByb3RvY29sID0gVjtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSTC5wcm90b3R5cGUsIFwidXNlcm5hbWVcIiwge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNbaW1wbF0udXNlcm5hbWU7XG4gIH0sXG4gIHNldChWKSB7XG4gICAgViA9IGNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdKFYpO1xuICAgIHRoaXNbaW1wbF0udXNlcm5hbWUgPSBWO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVVJMLnByb3RvdHlwZSwgXCJwYXNzd29yZFwiLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpc1tpbXBsXS5wYXNzd29yZDtcbiAgfSxcbiAgc2V0KFYpIHtcbiAgICBWID0gY29udmVyc2lvbnNbXCJVU1ZTdHJpbmdcIl0oVik7XG4gICAgdGhpc1tpbXBsXS5wYXNzd29yZCA9IFY7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkwucHJvdG90eXBlLCBcImhvc3RcIiwge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNbaW1wbF0uaG9zdDtcbiAgfSxcbiAgc2V0KFYpIHtcbiAgICBWID0gY29udmVyc2lvbnNbXCJVU1ZTdHJpbmdcIl0oVik7XG4gICAgdGhpc1tpbXBsXS5ob3N0ID0gVjtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSTC5wcm90b3R5cGUsIFwiaG9zdG5hbWVcIiwge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNbaW1wbF0uaG9zdG5hbWU7XG4gIH0sXG4gIHNldChWKSB7XG4gICAgViA9IGNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdKFYpO1xuICAgIHRoaXNbaW1wbF0uaG9zdG5hbWUgPSBWO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVVJMLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2ltcGxdLnBvcnQ7XG4gIH0sXG4gIHNldChWKSB7XG4gICAgViA9IGNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdKFYpO1xuICAgIHRoaXNbaW1wbF0ucG9ydCA9IFY7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkwucHJvdG90eXBlLCBcInBhdGhuYW1lXCIsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2ltcGxdLnBhdGhuYW1lO1xuICB9LFxuICBzZXQoVikge1xuICAgIFYgPSBjb252ZXJzaW9uc1tcIlVTVlN0cmluZ1wiXShWKTtcbiAgICB0aGlzW2ltcGxdLnBhdGhuYW1lID0gVjtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSTC5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2ltcGxdLnNlYXJjaDtcbiAgfSxcbiAgc2V0KFYpIHtcbiAgICBWID0gY29udmVyc2lvbnNbXCJVU1ZTdHJpbmdcIl0oVik7XG4gICAgdGhpc1tpbXBsXS5zZWFyY2ggPSBWO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVVJMLnByb3RvdHlwZSwgXCJoYXNoXCIsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2ltcGxdLmhhc2g7XG4gIH0sXG4gIHNldChWKSB7XG4gICAgViA9IGNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdKFYpO1xuICAgIHRoaXNbaW1wbF0uaGFzaCA9IFY7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzKG9iaikge1xuICAgIHJldHVybiAhIW9iaiAmJiBvYmpbaW1wbF0gaW5zdGFuY2VvZiBJbXBsLmltcGxlbWVudGF0aW9uO1xuICB9LFxuICBjcmVhdGUoY29uc3RydWN0b3JBcmdzLCBwcml2YXRlRGF0YSkge1xuICAgIGxldCBvYmogPSBPYmplY3QuY3JlYXRlKFVSTC5wcm90b3R5cGUpO1xuICAgIHRoaXMuc2V0dXAob2JqLCBjb25zdHJ1Y3RvckFyZ3MsIHByaXZhdGVEYXRhKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICBzZXR1cChvYmosIGNvbnN0cnVjdG9yQXJncywgcHJpdmF0ZURhdGEpIHtcbiAgICBpZiAoIXByaXZhdGVEYXRhKSBwcml2YXRlRGF0YSA9IHt9O1xuICAgIHByaXZhdGVEYXRhLndyYXBwZXIgPSBvYmo7XG5cbiAgICBvYmpbaW1wbF0gPSBuZXcgSW1wbC5pbXBsZW1lbnRhdGlvbihjb25zdHJ1Y3RvckFyZ3MsIHByaXZhdGVEYXRhKTtcbiAgICBvYmpbaW1wbF1bdXRpbHMud3JhcHBlclN5bWJvbF0gPSBvYmo7XG4gIH0sXG4gIGludGVyZmFjZTogVVJMLFxuICBleHBvc2U6IHtcbiAgICBXaW5kb3c6IHsgVVJMOiBVUkwgfSxcbiAgICBXb3JrZXI6IHsgVVJMOiBVUkwgfVxuICB9XG59O1xuXG4iXSwibmFtZXMiOlsiY29udmVyc2lvbnMiLCJyZXF1aXJlIiwidXRpbHMiLCJJbXBsIiwiaW1wbCIsImltcGxTeW1ib2wiLCJVUkwiLCJ1cmwiLCJUeXBlRXJyb3IiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiaSIsInVuZGVmaW5lZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZXR1cCIsInByb3RvdHlwZSIsInRvSlNPTiIsImlzIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImhyZWYiLCJzZXQiLCJWIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInRvU3RyaW5nIiwib3JpZ2luIiwicHJvdG9jb2wiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiaG9zdCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsIm9iaiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlIiwiY29uc3RydWN0b3JBcmdzIiwicHJpdmF0ZURhdGEiLCJ3cmFwcGVyIiwid3JhcHBlclN5bWJvbCIsImludGVyZmFjZSIsImV4cG9zZSIsIldpbmRvdyIsIldvcmtlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nexports.URL = __webpack_require__(/*! ./URL */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js\")[\"interface\"];\nexports.serializeURL = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").serializeURL;\nexports.serializeURLOrigin = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").serializeURLOrigin;\nexports.basicURLParse = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").basicURLParse;\nexports.setTheUsername = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").setTheUsername;\nexports.setThePassword = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").setThePassword;\nexports.serializeHost = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").serializeHost;\nexports.serializeInteger = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").serializeInteger;\nexports.parseURL = __webpack_require__(/*! ./url-state-machine */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\").parseURL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvcHVibGljLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSxpSUFBd0M7QUFDeENBLHNLQUFrRTtBQUNsRUEsa0xBQThFO0FBQzlFQSx3S0FBb0U7QUFDcEVBLDBLQUFzRTtBQUN0RUEsMEtBQXNFO0FBQ3RFQSx3S0FBb0U7QUFDcEVBLDhLQUEwRTtBQUMxRUEsOEpBQTBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvcHVibGljLWFwaS5qcz9kNjM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLlVSTCA9IHJlcXVpcmUoXCIuL1VSTFwiKS5pbnRlcmZhY2U7XG5leHBvcnRzLnNlcmlhbGl6ZVVSTCA9IHJlcXVpcmUoXCIuL3VybC1zdGF0ZS1tYWNoaW5lXCIpLnNlcmlhbGl6ZVVSTDtcbmV4cG9ydHMuc2VyaWFsaXplVVJMT3JpZ2luID0gcmVxdWlyZShcIi4vdXJsLXN0YXRlLW1hY2hpbmVcIikuc2VyaWFsaXplVVJMT3JpZ2luO1xuZXhwb3J0cy5iYXNpY1VSTFBhcnNlID0gcmVxdWlyZShcIi4vdXJsLXN0YXRlLW1hY2hpbmVcIikuYmFzaWNVUkxQYXJzZTtcbmV4cG9ydHMuc2V0VGhlVXNlcm5hbWUgPSByZXF1aXJlKFwiLi91cmwtc3RhdGUtbWFjaGluZVwiKS5zZXRUaGVVc2VybmFtZTtcbmV4cG9ydHMuc2V0VGhlUGFzc3dvcmQgPSByZXF1aXJlKFwiLi91cmwtc3RhdGUtbWFjaGluZVwiKS5zZXRUaGVQYXNzd29yZDtcbmV4cG9ydHMuc2VyaWFsaXplSG9zdCA9IHJlcXVpcmUoXCIuL3VybC1zdGF0ZS1tYWNoaW5lXCIpLnNlcmlhbGl6ZUhvc3Q7XG5leHBvcnRzLnNlcmlhbGl6ZUludGVnZXIgPSByZXF1aXJlKFwiLi91cmwtc3RhdGUtbWFjaGluZVwiKS5zZXJpYWxpemVJbnRlZ2VyO1xuZXhwb3J0cy5wYXJzZVVSTCA9IHJlcXVpcmUoXCIuL3VybC1zdGF0ZS1tYWNoaW5lXCIpLnBhcnNlVVJMO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJVUkwiLCJyZXF1aXJlIiwiaW50ZXJmYWNlIiwic2VyaWFsaXplVVJMIiwic2VyaWFsaXplVVJMT3JpZ2luIiwiYmFzaWNVUkxQYXJzZSIsInNldFRoZVVzZXJuYW1lIiwic2V0VGhlUGFzc3dvcmQiLCJzZXJpYWxpemVIb3N0Iiwic2VyaWFsaXplSW50ZWdlciIsInBhcnNlVVJMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst punycode = __webpack_require__(/*! punycode */ \"punycode\");\nconst tr46 = __webpack_require__(/*! tr46 */ \"(ssr)/./node_modules/tr46/index.js\");\nconst specialSchemes = {\n    ftp: 21,\n    file: null,\n    gopher: 70,\n    http: 80,\n    https: 443,\n    ws: 80,\n    wss: 443\n};\nconst failure = Symbol(\"failure\");\nfunction countSymbols(str) {\n    return punycode.ucs2.decode(str).length;\n}\nfunction at(input, idx) {\n    const c = input[idx];\n    return isNaN(c) ? undefined : String.fromCodePoint(c);\n}\nfunction isASCIIDigit(c) {\n    return c >= 0x30 && c <= 0x39;\n}\nfunction isASCIIAlpha(c) {\n    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;\n}\nfunction isASCIIAlphanumeric(c) {\n    return isASCIIAlpha(c) || isASCIIDigit(c);\n}\nfunction isASCIIHex(c) {\n    return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;\n}\nfunction isSingleDot(buffer) {\n    return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\n}\nfunction isDoubleDot(buffer) {\n    buffer = buffer.toLowerCase();\n    return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\n}\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\n    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\n}\nfunction isWindowsDriveLetterString(string) {\n    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\n}\nfunction isNormalizedWindowsDriveLetterString(string) {\n    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\n}\nfunction containsForbiddenHostCodePoint(string) {\n    return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\n}\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\n    return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\n}\nfunction isSpecialScheme(scheme) {\n    return specialSchemes[scheme] !== undefined;\n}\nfunction isSpecial(url) {\n    return isSpecialScheme(url.scheme);\n}\nfunction defaultPort(scheme) {\n    return specialSchemes[scheme];\n}\nfunction percentEncode(c) {\n    let hex = c.toString(16).toUpperCase();\n    if (hex.length === 1) {\n        hex = \"0\" + hex;\n    }\n    return \"%\" + hex;\n}\nfunction utf8PercentEncode(c) {\n    const buf = new Buffer(c);\n    let str = \"\";\n    for(let i = 0; i < buf.length; ++i){\n        str += percentEncode(buf[i]);\n    }\n    return str;\n}\nfunction utf8PercentDecode(str) {\n    const input = new Buffer(str);\n    const output = [];\n    for(let i = 0; i < input.length; ++i){\n        if (input[i] !== 37) {\n            output.push(input[i]);\n        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\n            output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\n            i += 2;\n        } else {\n            output.push(input[i]);\n        }\n    }\n    return new Buffer(output).toString();\n}\nfunction isC0ControlPercentEncode(c) {\n    return c <= 0x1F || c > 0x7E;\n}\nconst extraPathPercentEncodeSet = new Set([\n    32,\n    34,\n    35,\n    60,\n    62,\n    63,\n    96,\n    123,\n    125\n]);\nfunction isPathPercentEncode(c) {\n    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\n}\nconst extraUserinfoPercentEncodeSet = new Set([\n    47,\n    58,\n    59,\n    61,\n    64,\n    91,\n    92,\n    93,\n    94,\n    124\n]);\nfunction isUserinfoPercentEncode(c) {\n    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\n}\nfunction percentEncodeChar(c, encodeSetPredicate) {\n    const cStr = String.fromCodePoint(c);\n    if (encodeSetPredicate(c)) {\n        return utf8PercentEncode(cStr);\n    }\n    return cStr;\n}\nfunction parseIPv4Number(input) {\n    let R = 10;\n    if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\n        input = input.substring(2);\n        R = 16;\n    } else if (input.length >= 2 && input.charAt(0) === \"0\") {\n        input = input.substring(1);\n        R = 8;\n    }\n    if (input === \"\") {\n        return 0;\n    }\n    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;\n    if (regex.test(input)) {\n        return failure;\n    }\n    return parseInt(input, R);\n}\nfunction parseIPv4(input) {\n    const parts = input.split(\".\");\n    if (parts[parts.length - 1] === \"\") {\n        if (parts.length > 1) {\n            parts.pop();\n        }\n    }\n    if (parts.length > 4) {\n        return input;\n    }\n    const numbers = [];\n    for (const part of parts){\n        if (part === \"\") {\n            return input;\n        }\n        const n = parseIPv4Number(part);\n        if (n === failure) {\n            return input;\n        }\n        numbers.push(n);\n    }\n    for(let i = 0; i < numbers.length - 1; ++i){\n        if (numbers[i] > 255) {\n            return failure;\n        }\n    }\n    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\n        return failure;\n    }\n    let ipv4 = numbers.pop();\n    let counter = 0;\n    for (const n of numbers){\n        ipv4 += n * Math.pow(256, 3 - counter);\n        ++counter;\n    }\n    return ipv4;\n}\nfunction serializeIPv4(address) {\n    let output = \"\";\n    let n = address;\n    for(let i = 1; i <= 4; ++i){\n        output = String(n % 256) + output;\n        if (i !== 4) {\n            output = \".\" + output;\n        }\n        n = Math.floor(n / 256);\n    }\n    return output;\n}\nfunction parseIPv6(input) {\n    const address = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    let pieceIndex = 0;\n    let compress = null;\n    let pointer = 0;\n    input = punycode.ucs2.decode(input);\n    if (input[pointer] === 58) {\n        if (input[pointer + 1] !== 58) {\n            return failure;\n        }\n        pointer += 2;\n        ++pieceIndex;\n        compress = pieceIndex;\n    }\n    while(pointer < input.length){\n        if (pieceIndex === 8) {\n            return failure;\n        }\n        if (input[pointer] === 58) {\n            if (compress !== null) {\n                return failure;\n            }\n            ++pointer;\n            ++pieceIndex;\n            compress = pieceIndex;\n            continue;\n        }\n        let value = 0;\n        let length = 0;\n        while(length < 4 && isASCIIHex(input[pointer])){\n            value = value * 0x10 + parseInt(at(input, pointer), 16);\n            ++pointer;\n            ++length;\n        }\n        if (input[pointer] === 46) {\n            if (length === 0) {\n                return failure;\n            }\n            pointer -= length;\n            if (pieceIndex > 6) {\n                return failure;\n            }\n            let numbersSeen = 0;\n            while(input[pointer] !== undefined){\n                let ipv4Piece = null;\n                if (numbersSeen > 0) {\n                    if (input[pointer] === 46 && numbersSeen < 4) {\n                        ++pointer;\n                    } else {\n                        return failure;\n                    }\n                }\n                if (!isASCIIDigit(input[pointer])) {\n                    return failure;\n                }\n                while(isASCIIDigit(input[pointer])){\n                    const number = parseInt(at(input, pointer));\n                    if (ipv4Piece === null) {\n                        ipv4Piece = number;\n                    } else if (ipv4Piece === 0) {\n                        return failure;\n                    } else {\n                        ipv4Piece = ipv4Piece * 10 + number;\n                    }\n                    if (ipv4Piece > 255) {\n                        return failure;\n                    }\n                    ++pointer;\n                }\n                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\n                ++numbersSeen;\n                if (numbersSeen === 2 || numbersSeen === 4) {\n                    ++pieceIndex;\n                }\n            }\n            if (numbersSeen !== 4) {\n                return failure;\n            }\n            break;\n        } else if (input[pointer] === 58) {\n            ++pointer;\n            if (input[pointer] === undefined) {\n                return failure;\n            }\n        } else if (input[pointer] !== undefined) {\n            return failure;\n        }\n        address[pieceIndex] = value;\n        ++pieceIndex;\n    }\n    if (compress !== null) {\n        let swaps = pieceIndex - compress;\n        pieceIndex = 7;\n        while(pieceIndex !== 0 && swaps > 0){\n            const temp = address[compress + swaps - 1];\n            address[compress + swaps - 1] = address[pieceIndex];\n            address[pieceIndex] = temp;\n            --pieceIndex;\n            --swaps;\n        }\n    } else if (compress === null && pieceIndex !== 8) {\n        return failure;\n    }\n    return address;\n}\nfunction serializeIPv6(address) {\n    let output = \"\";\n    const seqResult = findLongestZeroSequence(address);\n    const compress = seqResult.idx;\n    let ignore0 = false;\n    for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex){\n        if (ignore0 && address[pieceIndex] === 0) {\n            continue;\n        } else if (ignore0) {\n            ignore0 = false;\n        }\n        if (compress === pieceIndex) {\n            const separator = pieceIndex === 0 ? \"::\" : \":\";\n            output += separator;\n            ignore0 = true;\n            continue;\n        }\n        output += address[pieceIndex].toString(16);\n        if (pieceIndex !== 7) {\n            output += \":\";\n        }\n    }\n    return output;\n}\nfunction parseHost(input, isSpecialArg) {\n    if (input[0] === \"[\") {\n        if (input[input.length - 1] !== \"]\") {\n            return failure;\n        }\n        return parseIPv6(input.substring(1, input.length - 1));\n    }\n    if (!isSpecialArg) {\n        return parseOpaqueHost(input);\n    }\n    const domain = utf8PercentDecode(input);\n    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\n    if (asciiDomain === null) {\n        return failure;\n    }\n    if (containsForbiddenHostCodePoint(asciiDomain)) {\n        return failure;\n    }\n    const ipv4Host = parseIPv4(asciiDomain);\n    if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\n        return ipv4Host;\n    }\n    return asciiDomain;\n}\nfunction parseOpaqueHost(input) {\n    if (containsForbiddenHostCodePointExcludingPercent(input)) {\n        return failure;\n    }\n    let output = \"\";\n    const decoded = punycode.ucs2.decode(input);\n    for(let i = 0; i < decoded.length; ++i){\n        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\n    }\n    return output;\n}\nfunction findLongestZeroSequence(arr) {\n    let maxIdx = null;\n    let maxLen = 1; // only find elements > 1\n    let currStart = null;\n    let currLen = 0;\n    for(let i = 0; i < arr.length; ++i){\n        if (arr[i] !== 0) {\n            if (currLen > maxLen) {\n                maxIdx = currStart;\n                maxLen = currLen;\n            }\n            currStart = null;\n            currLen = 0;\n        } else {\n            if (currStart === null) {\n                currStart = i;\n            }\n            ++currLen;\n        }\n    }\n    // if trailing zeros\n    if (currLen > maxLen) {\n        maxIdx = currStart;\n        maxLen = currLen;\n    }\n    return {\n        idx: maxIdx,\n        len: maxLen\n    };\n}\nfunction serializeHost(host) {\n    if (typeof host === \"number\") {\n        return serializeIPv4(host);\n    }\n    // IPv6 serializer\n    if (host instanceof Array) {\n        return \"[\" + serializeIPv6(host) + \"]\";\n    }\n    return host;\n}\nfunction trimControlChars(url) {\n    return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\n}\nfunction trimTabAndNewline(url) {\n    return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\n}\nfunction shortenPath(url) {\n    const path = url.path;\n    if (path.length === 0) {\n        return;\n    }\n    if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\n        return;\n    }\n    path.pop();\n}\nfunction includesCredentials(url) {\n    return url.username !== \"\" || url.password !== \"\";\n}\nfunction cannotHaveAUsernamePasswordPort(url) {\n    return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\n}\nfunction isNormalizedWindowsDriveLetter(string) {\n    return /^[A-Za-z]:$/.test(string);\n}\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\n    this.pointer = 0;\n    this.input = input;\n    this.base = base || null;\n    this.encodingOverride = encodingOverride || \"utf-8\";\n    this.stateOverride = stateOverride;\n    this.url = url;\n    this.failure = false;\n    this.parseError = false;\n    if (!this.url) {\n        this.url = {\n            scheme: \"\",\n            username: \"\",\n            password: \"\",\n            host: null,\n            port: null,\n            path: [],\n            query: null,\n            fragment: null,\n            cannotBeABaseURL: false\n        };\n        const res = trimControlChars(this.input);\n        if (res !== this.input) {\n            this.parseError = true;\n        }\n        this.input = res;\n    }\n    const res = trimTabAndNewline(this.input);\n    if (res !== this.input) {\n        this.parseError = true;\n    }\n    this.input = res;\n    this.state = stateOverride || \"scheme start\";\n    this.buffer = \"\";\n    this.atFlag = false;\n    this.arrFlag = false;\n    this.passwordTokenSeenFlag = false;\n    this.input = punycode.ucs2.decode(this.input);\n    for(; this.pointer <= this.input.length; ++this.pointer){\n        const c = this.input[this.pointer];\n        const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\n        // exec state machine\n        const ret = this[\"parse \" + this.state](c, cStr);\n        if (!ret) {\n            break; // terminate algorithm\n        } else if (ret === failure) {\n            this.failure = true;\n            break;\n        }\n    }\n}\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\n    if (isASCIIAlpha(c)) {\n        this.buffer += cStr.toLowerCase();\n        this.state = \"scheme\";\n    } else if (!this.stateOverride) {\n        this.state = \"no scheme\";\n        --this.pointer;\n    } else {\n        this.parseError = true;\n        return failure;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\n    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\n        this.buffer += cStr.toLowerCase();\n    } else if (c === 58) {\n        if (this.stateOverride) {\n            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\n                return false;\n            }\n            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\n                return false;\n            }\n            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\n                return false;\n            }\n            if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\n                return false;\n            }\n        }\n        this.url.scheme = this.buffer;\n        this.buffer = \"\";\n        if (this.stateOverride) {\n            return false;\n        }\n        if (this.url.scheme === \"file\") {\n            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\n                this.parseError = true;\n            }\n            this.state = \"file\";\n        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\n            this.state = \"special relative or authority\";\n        } else if (isSpecial(this.url)) {\n            this.state = \"special authority slashes\";\n        } else if (this.input[this.pointer + 1] === 47) {\n            this.state = \"path or authority\";\n            ++this.pointer;\n        } else {\n            this.url.cannotBeABaseURL = true;\n            this.url.path.push(\"\");\n            this.state = \"cannot-be-a-base-URL path\";\n        }\n    } else if (!this.stateOverride) {\n        this.buffer = \"\";\n        this.state = \"no scheme\";\n        this.pointer = -1;\n    } else {\n        this.parseError = true;\n        return failure;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\n    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {\n        return failure;\n    } else if (this.base.cannotBeABaseURL && c === 35) {\n        this.url.scheme = this.base.scheme;\n        this.url.path = this.base.path.slice();\n        this.url.query = this.base.query;\n        this.url.fragment = \"\";\n        this.url.cannotBeABaseURL = true;\n        this.state = \"fragment\";\n    } else if (this.base.scheme === \"file\") {\n        this.state = \"file\";\n        --this.pointer;\n    } else {\n        this.state = \"relative\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\n    if (c === 47 && this.input[this.pointer + 1] === 47) {\n        this.state = \"special authority ignore slashes\";\n        ++this.pointer;\n    } else {\n        this.parseError = true;\n        this.state = \"relative\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\n    if (c === 47) {\n        this.state = \"authority\";\n    } else {\n        this.state = \"path\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\n    this.url.scheme = this.base.scheme;\n    if (isNaN(c)) {\n        this.url.username = this.base.username;\n        this.url.password = this.base.password;\n        this.url.host = this.base.host;\n        this.url.port = this.base.port;\n        this.url.path = this.base.path.slice();\n        this.url.query = this.base.query;\n    } else if (c === 47) {\n        this.state = \"relative slash\";\n    } else if (c === 63) {\n        this.url.username = this.base.username;\n        this.url.password = this.base.password;\n        this.url.host = this.base.host;\n        this.url.port = this.base.port;\n        this.url.path = this.base.path.slice();\n        this.url.query = \"\";\n        this.state = \"query\";\n    } else if (c === 35) {\n        this.url.username = this.base.username;\n        this.url.password = this.base.password;\n        this.url.host = this.base.host;\n        this.url.port = this.base.port;\n        this.url.path = this.base.path.slice();\n        this.url.query = this.base.query;\n        this.url.fragment = \"\";\n        this.state = \"fragment\";\n    } else if (isSpecial(this.url) && c === 92) {\n        this.parseError = true;\n        this.state = \"relative slash\";\n    } else {\n        this.url.username = this.base.username;\n        this.url.password = this.base.password;\n        this.url.host = this.base.host;\n        this.url.port = this.base.port;\n        this.url.path = this.base.path.slice(0, this.base.path.length - 1);\n        this.state = \"path\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\n    if (isSpecial(this.url) && (c === 47 || c === 92)) {\n        if (c === 92) {\n            this.parseError = true;\n        }\n        this.state = \"special authority ignore slashes\";\n    } else if (c === 47) {\n        this.state = \"authority\";\n    } else {\n        this.url.username = this.base.username;\n        this.url.password = this.base.password;\n        this.url.host = this.base.host;\n        this.url.port = this.base.port;\n        this.state = \"path\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\n    if (c === 47 && this.input[this.pointer + 1] === 47) {\n        this.state = \"special authority ignore slashes\";\n        ++this.pointer;\n    } else {\n        this.parseError = true;\n        this.state = \"special authority ignore slashes\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\n    if (c !== 47 && c !== 92) {\n        this.state = \"authority\";\n        --this.pointer;\n    } else {\n        this.parseError = true;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\n    if (c === 64) {\n        this.parseError = true;\n        if (this.atFlag) {\n            this.buffer = \"%40\" + this.buffer;\n        }\n        this.atFlag = true;\n        // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\n        const len = countSymbols(this.buffer);\n        for(let pointer = 0; pointer < len; ++pointer){\n            const codePoint = this.buffer.codePointAt(pointer);\n            if (codePoint === 58 && !this.passwordTokenSeenFlag) {\n                this.passwordTokenSeenFlag = true;\n                continue;\n            }\n            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\n            if (this.passwordTokenSeenFlag) {\n                this.url.password += encodedCodePoints;\n            } else {\n                this.url.username += encodedCodePoints;\n            }\n        }\n        this.buffer = \"\";\n    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {\n        if (this.atFlag && this.buffer === \"\") {\n            this.parseError = true;\n            return failure;\n        }\n        this.pointer -= countSymbols(this.buffer) + 1;\n        this.buffer = \"\";\n        this.state = \"host\";\n    } else {\n        this.buffer += cStr;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse hostname\"] = URLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\n    if (this.stateOverride && this.url.scheme === \"file\") {\n        --this.pointer;\n        this.state = \"file host\";\n    } else if (c === 58 && !this.arrFlag) {\n        if (this.buffer === \"\") {\n            this.parseError = true;\n            return failure;\n        }\n        const host = parseHost(this.buffer, isSpecial(this.url));\n        if (host === failure) {\n            return failure;\n        }\n        this.url.host = host;\n        this.buffer = \"\";\n        this.state = \"port\";\n        if (this.stateOverride === \"hostname\") {\n            return false;\n        }\n    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {\n        --this.pointer;\n        if (isSpecial(this.url) && this.buffer === \"\") {\n            this.parseError = true;\n            return failure;\n        } else if (this.stateOverride && this.buffer === \"\" && (includesCredentials(this.url) || this.url.port !== null)) {\n            this.parseError = true;\n            return false;\n        }\n        const host = parseHost(this.buffer, isSpecial(this.url));\n        if (host === failure) {\n            return failure;\n        }\n        this.url.host = host;\n        this.buffer = \"\";\n        this.state = \"path start\";\n        if (this.stateOverride) {\n            return false;\n        }\n    } else {\n        if (c === 91) {\n            this.arrFlag = true;\n        } else if (c === 93) {\n            this.arrFlag = false;\n        }\n        this.buffer += cStr;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\n    if (isASCIIDigit(c)) {\n        this.buffer += cStr;\n    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {\n        if (this.buffer !== \"\") {\n            const port = parseInt(this.buffer);\n            if (port > Math.pow(2, 16) - 1) {\n                this.parseError = true;\n                return failure;\n            }\n            this.url.port = port === defaultPort(this.url.scheme) ? null : port;\n            this.buffer = \"\";\n        }\n        if (this.stateOverride) {\n            return false;\n        }\n        this.state = \"path start\";\n        --this.pointer;\n    } else {\n        this.parseError = true;\n        return failure;\n    }\n    return true;\n};\nconst fileOtherwiseCodePoints = new Set([\n    47,\n    92,\n    63,\n    35\n]);\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\n    this.url.scheme = \"file\";\n    if (c === 47 || c === 92) {\n        if (c === 92) {\n            this.parseError = true;\n        }\n        this.state = \"file slash\";\n    } else if (this.base !== null && this.base.scheme === \"file\") {\n        if (isNaN(c)) {\n            this.url.host = this.base.host;\n            this.url.path = this.base.path.slice();\n            this.url.query = this.base.query;\n        } else if (c === 63) {\n            this.url.host = this.base.host;\n            this.url.path = this.base.path.slice();\n            this.url.query = \"\";\n            this.state = \"query\";\n        } else if (c === 35) {\n            this.url.host = this.base.host;\n            this.url.path = this.base.path.slice();\n            this.url.query = this.base.query;\n            this.url.fragment = \"\";\n            this.state = \"fragment\";\n        } else {\n            if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\n            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\n            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {\n                this.url.host = this.base.host;\n                this.url.path = this.base.path.slice();\n                shortenPath(this.url);\n            } else {\n                this.parseError = true;\n            }\n            this.state = \"path\";\n            --this.pointer;\n        }\n    } else {\n        this.state = \"path\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\n    if (c === 47 || c === 92) {\n        if (c === 92) {\n            this.parseError = true;\n        }\n        this.state = \"file host\";\n    } else {\n        if (this.base !== null && this.base.scheme === \"file\") {\n            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\n                this.url.path.push(this.base.path[0]);\n            } else {\n                this.url.host = this.base.host;\n            }\n        }\n        this.state = \"path\";\n        --this.pointer;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\n    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\n        --this.pointer;\n        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\n            this.parseError = true;\n            this.state = \"path\";\n        } else if (this.buffer === \"\") {\n            this.url.host = \"\";\n            if (this.stateOverride) {\n                return false;\n            }\n            this.state = \"path start\";\n        } else {\n            let host = parseHost(this.buffer, isSpecial(this.url));\n            if (host === failure) {\n                return failure;\n            }\n            if (host === \"localhost\") {\n                host = \"\";\n            }\n            this.url.host = host;\n            if (this.stateOverride) {\n                return false;\n            }\n            this.buffer = \"\";\n            this.state = \"path start\";\n        }\n    } else {\n        this.buffer += cStr;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\n    if (isSpecial(this.url)) {\n        if (c === 92) {\n            this.parseError = true;\n        }\n        this.state = \"path\";\n        if (c !== 47 && c !== 92) {\n            --this.pointer;\n        }\n    } else if (!this.stateOverride && c === 63) {\n        this.url.query = \"\";\n        this.state = \"query\";\n    } else if (!this.stateOverride && c === 35) {\n        this.url.fragment = \"\";\n        this.state = \"fragment\";\n    } else if (c !== undefined) {\n        this.state = \"path\";\n        if (c !== 47) {\n            --this.pointer;\n        }\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\n    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {\n        if (isSpecial(this.url) && c === 92) {\n            this.parseError = true;\n        }\n        if (isDoubleDot(this.buffer)) {\n            shortenPath(this.url);\n            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\n                this.url.path.push(\"\");\n            }\n        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {\n            this.url.path.push(\"\");\n        } else if (!isSingleDot(this.buffer)) {\n            if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\n                if (this.url.host !== \"\" && this.url.host !== null) {\n                    this.parseError = true;\n                    this.url.host = \"\";\n                }\n                this.buffer = this.buffer[0] + \":\";\n            }\n            this.url.path.push(this.buffer);\n        }\n        this.buffer = \"\";\n        if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\n            while(this.url.path.length > 1 && this.url.path[0] === \"\"){\n                this.parseError = true;\n                this.url.path.shift();\n            }\n        }\n        if (c === 63) {\n            this.url.query = \"\";\n            this.state = \"query\";\n        }\n        if (c === 35) {\n            this.url.fragment = \"\";\n            this.state = \"fragment\";\n        }\n    } else {\n        // TODO: If c is not a URL code point and not \"%\", parse error.\n        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {\n            this.parseError = true;\n        }\n        this.buffer += percentEncodeChar(c, isPathPercentEncode);\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\n    if (c === 63) {\n        this.url.query = \"\";\n        this.state = \"query\";\n    } else if (c === 35) {\n        this.url.fragment = \"\";\n        this.state = \"fragment\";\n    } else {\n        // TODO: Add: not a URL code point\n        if (!isNaN(c) && c !== 37) {\n            this.parseError = true;\n        }\n        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {\n            this.parseError = true;\n        }\n        if (!isNaN(c)) {\n            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\n        }\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\n    if (isNaN(c) || !this.stateOverride && c === 35) {\n        if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\n            this.encodingOverride = \"utf-8\";\n        }\n        const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\n        for(let i = 0; i < buffer.length; ++i){\n            if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 || buffer[i] === 0x3C || buffer[i] === 0x3E) {\n                this.url.query += percentEncode(buffer[i]);\n            } else {\n                this.url.query += String.fromCodePoint(buffer[i]);\n            }\n        }\n        this.buffer = \"\";\n        if (c === 35) {\n            this.url.fragment = \"\";\n            this.state = \"fragment\";\n        }\n    } else {\n        // TODO: If c is not a URL code point and not \"%\", parse error.\n        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {\n            this.parseError = true;\n        }\n        this.buffer += cStr;\n    }\n    return true;\n};\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\n    if (isNaN(c)) {} else if (c === 0x0) {\n        this.parseError = true;\n    } else {\n        // TODO: If c is not a URL code point and not \"%\", parse error.\n        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {\n            this.parseError = true;\n        }\n        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\n    }\n    return true;\n};\nfunction serializeURL(url, excludeFragment) {\n    let output = url.scheme + \":\";\n    if (url.host !== null) {\n        output += \"//\";\n        if (url.username !== \"\" || url.password !== \"\") {\n            output += url.username;\n            if (url.password !== \"\") {\n                output += \":\" + url.password;\n            }\n            output += \"@\";\n        }\n        output += serializeHost(url.host);\n        if (url.port !== null) {\n            output += \":\" + url.port;\n        }\n    } else if (url.host === null && url.scheme === \"file\") {\n        output += \"//\";\n    }\n    if (url.cannotBeABaseURL) {\n        output += url.path[0];\n    } else {\n        for (const string of url.path){\n            output += \"/\" + string;\n        }\n    }\n    if (url.query !== null) {\n        output += \"?\" + url.query;\n    }\n    if (!excludeFragment && url.fragment !== null) {\n        output += \"#\" + url.fragment;\n    }\n    return output;\n}\nfunction serializeOrigin(tuple) {\n    let result = tuple.scheme + \"://\";\n    result += serializeHost(tuple.host);\n    if (tuple.port !== null) {\n        result += \":\" + tuple.port;\n    }\n    return result;\n}\nmodule.exports.serializeURL = serializeURL;\nmodule.exports.serializeURLOrigin = function(url) {\n    // https://url.spec.whatwg.org/#concept-url-origin\n    switch(url.scheme){\n        case \"blob\":\n            try {\n                return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\n            } catch (e) {\n                // serializing an opaque origin returns \"null\"\n                return \"null\";\n            }\n        case \"ftp\":\n        case \"gopher\":\n        case \"http\":\n        case \"https\":\n        case \"ws\":\n        case \"wss\":\n            return serializeOrigin({\n                scheme: url.scheme,\n                host: url.host,\n                port: url.port\n            });\n        case \"file\":\n            // spec says \"exercise to the reader\", chrome says \"file://\"\n            return \"file://\";\n        default:\n            // serializing an opaque origin returns \"null\"\n            return \"null\";\n    }\n};\nmodule.exports.basicURLParse = function(input, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\n    if (usm.failure) {\n        return \"failure\";\n    }\n    return usm.url;\n};\nmodule.exports.setTheUsername = function(url, username) {\n    url.username = \"\";\n    const decoded = punycode.ucs2.decode(username);\n    for(let i = 0; i < decoded.length; ++i){\n        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\n    }\n};\nmodule.exports.setThePassword = function(url, password) {\n    url.password = \"\";\n    const decoded = punycode.ucs2.decode(password);\n    for(let i = 0; i < decoded.length; ++i){\n        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\n    }\n};\nmodule.exports.serializeHost = serializeHost;\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\nmodule.exports.serializeInteger = function(integer) {\n    return String(integer);\n};\nmodule.exports.parseURL = function(input, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    // We don't handle blobs, so this just delegates:\n    return module.exports.basicURLParse(input, {\n        baseURL: options.baseURL,\n        encodingOverride: options.encodingOverride\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvdXJsLXN0YXRlLW1hY2hpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixNQUFNQSxXQUFXQyxtQkFBT0EsQ0FBQywwQkFBVTtBQUNuQyxNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxnREFBTTtBQUUzQixNQUFNRSxpQkFBaUI7SUFDckJDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxJQUFJO0lBQ0pDLEtBQUs7QUFDUDtBQUVBLE1BQU1DLFVBQVVDLE9BQU87QUFFdkIsU0FBU0MsYUFBYUMsR0FBRztJQUN2QixPQUFPZCxTQUFTZSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0YsS0FBS0csTUFBTTtBQUN6QztBQUVBLFNBQVNDLEdBQUdDLEtBQUssRUFBRUMsR0FBRztJQUNwQixNQUFNQyxJQUFJRixLQUFLLENBQUNDLElBQUk7SUFDcEIsT0FBT0UsTUFBTUQsS0FBS0UsWUFBWUMsT0FBT0MsYUFBYSxDQUFDSjtBQUNyRDtBQUVBLFNBQVNLLGFBQWFMLENBQUM7SUFDckIsT0FBT0EsS0FBSyxRQUFRQSxLQUFLO0FBQzNCO0FBRUEsU0FBU00sYUFBYU4sQ0FBQztJQUNyQixPQUFPLEtBQU0sUUFBUUEsS0FBSyxRQUFVQSxLQUFLLFFBQVFBLEtBQUs7QUFDeEQ7QUFFQSxTQUFTTyxvQkFBb0JQLENBQUM7SUFDNUIsT0FBT00sYUFBYU4sTUFBTUssYUFBYUw7QUFDekM7QUFFQSxTQUFTUSxXQUFXUixDQUFDO0lBQ25CLE9BQU9LLGFBQWFMLE1BQU9BLEtBQUssUUFBUUEsS0FBSyxRQUFVQSxLQUFLLFFBQVFBLEtBQUs7QUFDM0U7QUFFQSxTQUFTUyxZQUFZQyxNQUFNO0lBQ3pCLE9BQU9BLFdBQVcsT0FBT0EsT0FBT0MsV0FBVyxPQUFPO0FBQ3BEO0FBRUEsU0FBU0MsWUFBWUYsTUFBTTtJQUN6QkEsU0FBU0Es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a0JBQWtCK0MsT0FBTyxDQUFDNUQsRUFBRSxFQUFFWTtJQUNoRDtBQUNGO0FBRUFpSCw0QkFBNEIsR0FBRzFEO0FBRS9CMEQsOENBQThDLEdBQUc5QztBQUVqRDhDLCtCQUErQixHQUFHLFNBQVVZLE9BQU87SUFDakQsT0FBT3pLLE9BQU95SztBQUNoQjtBQUVBWix1QkFBdUIsR0FBRyxTQUFVbEssS0FBSyxFQUFFd0ssT0FBTztJQUNoRCxJQUFJQSxZQUFZcEssV0FBVztRQUN6Qm9LLFVBQVUsQ0FBQztJQUNiO0lBRUEsaURBQWlEO0lBQ2pELE9BQU9OLE9BQU9DLE9BQU8sQ0FBQ0ksYUFBYSxDQUFDdkssT0FBTztRQUFFMEssU0FBU0YsUUFBUUUsT0FBTztRQUFFbEQsa0JBQWtCZ0QsUUFBUWhELGdCQUFnQjtJQUFDO0FBQ3BIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvdXJsLXN0YXRlLW1hY2hpbmUuanM/MTE2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuY29uc3QgcHVueWNvZGUgPSByZXF1aXJlKFwicHVueWNvZGVcIik7XHJcbmNvbnN0IHRyNDYgPSByZXF1aXJlKFwidHI0NlwiKTtcclxuXHJcbmNvbnN0IHNwZWNpYWxTY2hlbWVzID0ge1xyXG4gIGZ0cDogMjEsXHJcbiAgZmlsZTogbnVsbCxcclxuICBnb3BoZXI6IDcwLFxyXG4gIGh0dHA6IDgwLFxyXG4gIGh0dHBzOiA0NDMsXHJcbiAgd3M6IDgwLFxyXG4gIHdzczogNDQzXHJcbn07XHJcblxyXG5jb25zdCBmYWlsdXJlID0gU3ltYm9sKFwiZmFpbHVyZVwiKTtcclxuXHJcbmZ1bmN0aW9uIGNvdW50U3ltYm9scyhzdHIpIHtcclxuICByZXR1cm4gcHVueWNvZGUudWNzMi5kZWNvZGUoc3RyKS5sZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0KGlucHV0LCBpZHgpIHtcclxuICBjb25zdCBjID0gaW5wdXRbaWR4XTtcclxuICByZXR1cm4gaXNOYU4oYykgPyB1bmRlZmluZWQgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBU0NJSURpZ2l0KGMpIHtcclxuICByZXR1cm4gYyA+PSAweDMwICYmIGMgPD0gMHgzOTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBU0NJSUFscGhhKGMpIHtcclxuICByZXR1cm4gKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBU0NJSUFscGhhbnVtZXJpYyhjKSB7XHJcbiAgcmV0dXJuIGlzQVNDSUlBbHBoYShjKSB8fCBpc0FTQ0lJRGlnaXQoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQVNDSUlIZXgoYykge1xyXG4gIHJldHVybiBpc0FTQ0lJRGlnaXQoYykgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NDYpIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDY2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTaW5nbGVEb3QoYnVmZmVyKSB7XHJcbiAgcmV0dXJuIGJ1ZmZlciA9PT0gXCIuXCIgfHwgYnVmZmVyLnRvTG93ZXJDYXNlKCkgPT09IFwiJTJlXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRG91YmxlRG90KGJ1ZmZlcikge1xyXG4gIGJ1ZmZlciA9IGJ1ZmZlci50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBidWZmZXIgPT09IFwiLi5cIiB8fCBidWZmZXIgPT09IFwiJTJlLlwiIHx8IGJ1ZmZlciA9PT0gXCIuJTJlXCIgfHwgYnVmZmVyID09PSBcIiUyZSUyZVwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1dpbmRvd3NEcml2ZUxldHRlckNvZGVQb2ludHMoY3AxLCBjcDIpIHtcclxuICByZXR1cm4gaXNBU0NJSUFscGhhKGNwMSkgJiYgKGNwMiA9PT0gNTggfHwgY3AyID09PSAxMjQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1dpbmRvd3NEcml2ZUxldHRlclN0cmluZyhzdHJpbmcpIHtcclxuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA9PT0gMiAmJiBpc0FTQ0lJQWxwaGEoc3RyaW5nLmNvZGVQb2ludEF0KDApKSAmJiAoc3RyaW5nWzFdID09PSBcIjpcIiB8fCBzdHJpbmdbMV0gPT09IFwifFwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOb3JtYWxpemVkV2luZG93c0RyaXZlTGV0dGVyU3RyaW5nKHN0cmluZykge1xyXG4gIHJldHVybiBzdHJpbmcubGVuZ3RoID09PSAyICYmIGlzQVNDSUlBbHBoYShzdHJpbmcuY29kZVBvaW50QXQoMCkpICYmIHN0cmluZ1sxXSA9PT0gXCI6XCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5zRm9yYmlkZGVuSG9zdENvZGVQb2ludChzdHJpbmcpIHtcclxuICByZXR1cm4gc3RyaW5nLnNlYXJjaCgvXFx1MDAwMHxcXHUwMDA5fFxcdTAwMEF8XFx1MDAwRHxcXHUwMDIwfCN8JXxcXC98OnxcXD98QHxcXFt8XFxcXHxcXF0vKSAhPT0gLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5zRm9yYmlkZGVuSG9zdENvZGVQb2ludEV4Y2x1ZGluZ1BlcmNlbnQoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy5zZWFyY2goL1xcdTAwMDB8XFx1MDAwOXxcXHUwMDBBfFxcdTAwMER8XFx1MDAyMHwjfFxcL3w6fFxcP3xAfFxcW3xcXFxcfFxcXS8pICE9PSAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTcGVjaWFsU2NoZW1lKHNjaGVtZSkge1xyXG4gIHJldHVybiBzcGVjaWFsU2NoZW1lc1tzY2hlbWVdICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3BlY2lhbCh1cmwpIHtcclxuICByZXR1cm4gaXNTcGVjaWFsU2NoZW1lKHVybC5zY2hlbWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UG9ydChzY2hlbWUpIHtcclxuICByZXR1cm4gc3BlY2lhbFNjaGVtZXNbc2NoZW1lXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGVyY2VudEVuY29kZShjKSB7XHJcbiAgbGV0IGhleCA9IGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XHJcbiAgaWYgKGhleC5sZW5ndGggPT09IDEpIHtcclxuICAgIGhleCA9IFwiMFwiICsgaGV4O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFwiJVwiICsgaGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiB1dGY4UGVyY2VudEVuY29kZShjKSB7XHJcbiAgY29uc3QgYnVmID0gbmV3IEJ1ZmZlcihjKTtcclxuXHJcbiAgbGV0IHN0ciA9IFwiXCI7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKSB7XHJcbiAgICBzdHIgKz0gcGVyY2VudEVuY29kZShidWZbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuZnVuY3Rpb24gdXRmOFBlcmNlbnREZWNvZGUoc3RyKSB7XHJcbiAgY29uc3QgaW5wdXQgPSBuZXcgQnVmZmVyKHN0cik7XHJcbiAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGlucHV0W2ldICE9PSAzNykge1xyXG4gICAgICBvdXRwdXQucHVzaChpbnB1dFtpXSk7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0W2ldID09PSAzNyAmJiBpc0FTQ0lJSGV4KGlucHV0W2kgKyAxXSkgJiYgaXNBU0NJSUhleChpbnB1dFtpICsgMl0pKSB7XHJcbiAgICAgIG91dHB1dC5wdXNoKHBhcnNlSW50KGlucHV0LnNsaWNlKGkgKyAxLCBpICsgMykudG9TdHJpbmcoKSwgMTYpKTtcclxuICAgICAgaSArPSAyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3V0cHV0LnB1c2goaW5wdXRbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXRwdXQpLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQzBDb250cm9sUGVyY2VudEVuY29kZShjKSB7XHJcbiAgcmV0dXJuIGMgPD0gMHgxRiB8fCBjID4gMHg3RTtcclxufVxyXG5cclxuY29uc3QgZXh0cmFQYXRoUGVyY2VudEVuY29kZVNldCA9IG5ldyBTZXQoWzMyLCAzNCwgMzUsIDYwLCA2MiwgNjMsIDk2LCAxMjMsIDEyNV0pO1xyXG5mdW5jdGlvbiBpc1BhdGhQZXJjZW50RW5jb2RlKGMpIHtcclxuICByZXR1cm4gaXNDMENvbnRyb2xQZXJjZW50RW5jb2RlKGMpIHx8IGV4dHJhUGF0aFBlcmNlbnRFbmNvZGVTZXQuaGFzKGMpO1xyXG59XHJcblxyXG5jb25zdCBleHRyYVVzZXJpbmZvUGVyY2VudEVuY29kZVNldCA9XHJcbiAgbmV3IFNldChbNDcsIDU4LCA1OSwgNjEsIDY0LCA5MSwgOTIsIDkzLCA5NCwgMTI0XSk7XHJcbmZ1bmN0aW9uIGlzVXNlcmluZm9QZXJjZW50RW5jb2RlKGMpIHtcclxuICByZXR1cm4gaXNQYXRoUGVyY2VudEVuY29kZShjKSB8fCBleHRyYVVzZXJpbmZvUGVyY2VudEVuY29kZVNldC5oYXMoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBlcmNlbnRFbmNvZGVDaGFyKGMsIGVuY29kZVNldFByZWRpY2F0ZSkge1xyXG4gIGNvbnN0IGNTdHIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcclxuXHJcbiAgaWYgKGVuY29kZVNldFByZWRpY2F0ZShjKSkge1xyXG4gICAgcmV0dXJuIHV0ZjhQZXJjZW50RW5jb2RlKGNTdHIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNTdHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSVB2NE51bWJlcihpbnB1dCkge1xyXG4gIGxldCBSID0gMTA7XHJcblxyXG4gIGlmIChpbnB1dC5sZW5ndGggPj0gMiAmJiBpbnB1dC5jaGFyQXQoMCkgPT09IFwiMFwiICYmIGlucHV0LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSBcInhcIikge1xyXG4gICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoMik7XHJcbiAgICBSID0gMTY7XHJcbiAgfSBlbHNlIGlmIChpbnB1dC5sZW5ndGggPj0gMiAmJiBpbnB1dC5jaGFyQXQoMCkgPT09IFwiMFwiKSB7XHJcbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygxKTtcclxuICAgIFIgPSA4O1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0ID09PSBcIlwiKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlZ2V4ID0gUiA9PT0gMTAgPyAvW14wLTldLyA6IChSID09PSAxNiA/IC9bXjAtOUEtRmEtZl0vIDogL1teMC03XS8pO1xyXG4gIGlmIChyZWdleC50ZXN0KGlucHV0KSkge1xyXG4gICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIFIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUlQdjQoaW5wdXQpIHtcclxuICBjb25zdCBwYXJ0cyA9IGlucHV0LnNwbGl0KFwiLlwiKTtcclxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT09IFwiXCIpIHtcclxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHBhcnRzLnBvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDQpIHtcclxuICAgIHJldHVybiBpbnB1dDtcclxuICB9XHJcblxyXG4gIGNvbnN0IG51bWJlcnMgPSBbXTtcclxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcclxuICAgIGlmIChwYXJ0ID09PSBcIlwiKSB7XHJcbiAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuICAgIGNvbnN0IG4gPSBwYXJzZUlQdjROdW1iZXIocGFydCk7XHJcbiAgICBpZiAobiA9PT0gZmFpbHVyZSkge1xyXG4gICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgbnVtYmVycy5wdXNoKG4pO1xyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aCAtIDE7ICsraSkge1xyXG4gICAgaWYgKG51bWJlcnNbaV0gPiAyNTUpIHtcclxuICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChudW1iZXJzW251bWJlcnMubGVuZ3RoIC0gMV0gPj0gTWF0aC5wb3coMjU2LCA1IC0gbnVtYmVycy5sZW5ndGgpKSB7XHJcbiAgICByZXR1cm4gZmFpbHVyZTtcclxuICB9XHJcblxyXG4gIGxldCBpcHY0ID0gbnVtYmVycy5wb3AoKTtcclxuICBsZXQgY291bnRlciA9IDA7XHJcblxyXG4gIGZvciAoY29uc3QgbiBvZiBudW1iZXJzKSB7XHJcbiAgICBpcHY0ICs9IG4gKiBNYXRoLnBvdygyNTYsIDMgLSBjb3VudGVyKTtcclxuICAgICsrY291bnRlcjtcclxuICB9XHJcblxyXG4gIHJldHVybiBpcHY0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemVJUHY0KGFkZHJlc3MpIHtcclxuICBsZXQgb3V0cHV0ID0gXCJcIjtcclxuICBsZXQgbiA9IGFkZHJlc3M7XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDQ7ICsraSkge1xyXG4gICAgb3V0cHV0ID0gU3RyaW5nKG4gJSAyNTYpICsgb3V0cHV0O1xyXG4gICAgaWYgKGkgIT09IDQpIHtcclxuICAgICAgb3V0cHV0ID0gXCIuXCIgKyBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBuID0gTWF0aC5mbG9vcihuIC8gMjU2KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSVB2NihpbnB1dCkge1xyXG4gIGNvbnN0IGFkZHJlc3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XHJcbiAgbGV0IHBpZWNlSW5kZXggPSAwO1xyXG4gIGxldCBjb21wcmVzcyA9IG51bGw7XHJcbiAgbGV0IHBvaW50ZXIgPSAwO1xyXG5cclxuICBpbnB1dCA9IHB1bnljb2RlLnVjczIuZGVjb2RlKGlucHV0KTtcclxuXHJcbiAgaWYgKGlucHV0W3BvaW50ZXJdID09PSA1OCkge1xyXG4gICAgaWYgKGlucHV0W3BvaW50ZXIgKyAxXSAhPT0gNTgpIHtcclxuICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgcG9pbnRlciArPSAyO1xyXG4gICAgKytwaWVjZUluZGV4O1xyXG4gICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBpbnB1dC5sZW5ndGgpIHtcclxuICAgIGlmIChwaWVjZUluZGV4ID09PSA4KSB7XHJcbiAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnB1dFtwb2ludGVyXSA9PT0gNTgpIHtcclxuICAgICAgaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgIH1cclxuICAgICAgKytwb2ludGVyO1xyXG4gICAgICArK3BpZWNlSW5kZXg7XHJcbiAgICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHZhbHVlID0gMDtcclxuICAgIGxldCBsZW5ndGggPSAwO1xyXG5cclxuICAgIHdoaWxlIChsZW5ndGggPCA0ICYmIGlzQVNDSUlIZXgoaW5wdXRbcG9pbnRlcl0pKSB7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUgKiAweDEwICsgcGFyc2VJbnQoYXQoaW5wdXQsIHBvaW50ZXIpLCAxNik7XHJcbiAgICAgICsrcG9pbnRlcjtcclxuICAgICAgKytsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlucHV0W3BvaW50ZXJdID09PSA0Nikge1xyXG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBvaW50ZXIgLT0gbGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHBpZWNlSW5kZXggPiA2KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBudW1iZXJzU2VlbiA9IDA7XHJcblxyXG4gICAgICB3aGlsZSAoaW5wdXRbcG9pbnRlcl0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxldCBpcHY0UGllY2UgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPiAwKSB7XHJcbiAgICAgICAgICBpZiAoaW5wdXRbcG9pbnRlcl0gPT09IDQ2ICYmIG51bWJlcnNTZWVuIDwgNCkge1xyXG4gICAgICAgICAgICArK3BvaW50ZXI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFpbHVyZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNBU0NJSURpZ2l0KGlucHV0W3BvaW50ZXJdKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSAoaXNBU0NJSURpZ2l0KGlucHV0W3BvaW50ZXJdKSkge1xyXG4gICAgICAgICAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQoYXQoaW5wdXQsIHBvaW50ZXIpKTtcclxuICAgICAgICAgIGlmIChpcHY0UGllY2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaXB2NFBpZWNlID0gbnVtYmVyO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpcHY0UGllY2UgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpcHY0UGllY2UgPSBpcHY0UGllY2UgKiAxMCArIG51bWJlcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpcHY0UGllY2UgPiAyNTUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICArK3BvaW50ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRyZXNzW3BpZWNlSW5kZXhdID0gYWRkcmVzc1twaWVjZUluZGV4XSAqIDB4MTAwICsgaXB2NFBpZWNlO1xyXG5cclxuICAgICAgICArK251bWJlcnNTZWVuO1xyXG5cclxuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPT09IDIgfHwgbnVtYmVyc1NlZW4gPT09IDQpIHtcclxuICAgICAgICAgICsrcGllY2VJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChudW1iZXJzU2VlbiAhPT0gNCkge1xyXG4gICAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBicmVhaztcclxuICAgIH0gZWxzZSBpZiAoaW5wdXRbcG9pbnRlcl0gPT09IDU4KSB7XHJcbiAgICAgICsrcG9pbnRlcjtcclxuICAgICAgaWYgKGlucHV0W3BvaW50ZXJdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFpbHVyZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpbnB1dFtwb2ludGVyXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSB2YWx1ZTtcclxuICAgICsrcGllY2VJbmRleDtcclxuICB9XHJcblxyXG4gIGlmIChjb21wcmVzcyAhPT0gbnVsbCkge1xyXG4gICAgbGV0IHN3YXBzID0gcGllY2VJbmRleCAtIGNvbXByZXNzO1xyXG4gICAgcGllY2VJbmRleCA9IDc7XHJcbiAgICB3aGlsZSAocGllY2VJbmRleCAhPT0gMCAmJiBzd2FwcyA+IDApIHtcclxuICAgICAgY29uc3QgdGVtcCA9IGFkZHJlc3NbY29tcHJlc3MgKyBzd2FwcyAtIDFdO1xyXG4gICAgICBhZGRyZXNzW2NvbXByZXNzICsgc3dhcHMgLSAxXSA9IGFkZHJlc3NbcGllY2VJbmRleF07XHJcbiAgICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSB0ZW1wO1xyXG4gICAgICAtLXBpZWNlSW5kZXg7XHJcbiAgICAgIC0tc3dhcHM7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChjb21wcmVzcyA9PT0gbnVsbCAmJiBwaWVjZUluZGV4ICE9PSA4KSB7XHJcbiAgICByZXR1cm4gZmFpbHVyZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhZGRyZXNzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemVJUHY2KGFkZHJlc3MpIHtcclxuICBsZXQgb3V0cHV0ID0gXCJcIjtcclxuICBjb25zdCBzZXFSZXN1bHQgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShhZGRyZXNzKTtcclxuICBjb25zdCBjb21wcmVzcyA9IHNlcVJlc3VsdC5pZHg7XHJcbiAgbGV0IGlnbm9yZTAgPSBmYWxzZTtcclxuXHJcbiAgZm9yIChsZXQgcGllY2VJbmRleCA9IDA7IHBpZWNlSW5kZXggPD0gNzsgKytwaWVjZUluZGV4KSB7XHJcbiAgICBpZiAoaWdub3JlMCAmJiBhZGRyZXNzW3BpZWNlSW5kZXhdID09PSAwKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfSBlbHNlIGlmIChpZ25vcmUwKSB7XHJcbiAgICAgIGlnbm9yZTAgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29tcHJlc3MgPT09IHBpZWNlSW5kZXgpIHtcclxuICAgICAgY29uc3Qgc2VwYXJhdG9yID0gcGllY2VJbmRleCA9PT0gMCA/IFwiOjpcIiA6IFwiOlwiO1xyXG4gICAgICBvdXRwdXQgKz0gc2VwYXJhdG9yO1xyXG4gICAgICBpZ25vcmUwID0gdHJ1ZTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0ICs9IGFkZHJlc3NbcGllY2VJbmRleF0udG9TdHJpbmcoMTYpO1xyXG5cclxuICAgIGlmIChwaWVjZUluZGV4ICE9PSA3KSB7XHJcbiAgICAgIG91dHB1dCArPSBcIjpcIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSG9zdChpbnB1dCwgaXNTcGVjaWFsQXJnKSB7XHJcbiAgaWYgKGlucHV0WzBdID09PSBcIltcIikge1xyXG4gICAgaWYgKGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdICE9PSBcIl1cIikge1xyXG4gICAgICByZXR1cm4gZmFpbHVyZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyc2VJUHY2KGlucHV0LnN1YnN0cmluZygxLCBpbnB1dC5sZW5ndGggLSAxKSk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzU3BlY2lhbEFyZykge1xyXG4gICAgcmV0dXJuIHBhcnNlT3BhcXVlSG9zdChpbnB1dCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkb21haW4gPSB1dGY4UGVyY2VudERlY29kZShpbnB1dCk7XHJcbiAgY29uc3QgYXNjaWlEb21haW4gPSB0cjQ2LnRvQVNDSUkoZG9tYWluLCBmYWxzZSwgdHI0Ni5QUk9DRVNTSU5HX09QVElPTlMuTk9OVFJBTlNJVElPTkFMLCBmYWxzZSk7XHJcbiAgaWYgKGFzY2lpRG9tYWluID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFpbHVyZTtcclxuICB9XHJcblxyXG4gIGlmIChjb250YWluc0ZvcmJpZGRlbkhvc3RDb2RlUG9pbnQoYXNjaWlEb21haW4pKSB7XHJcbiAgICByZXR1cm4gZmFpbHVyZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlwdjRIb3N0ID0gcGFyc2VJUHY0KGFzY2lpRG9tYWluKTtcclxuICBpZiAodHlwZW9mIGlwdjRIb3N0ID09PSBcIm51bWJlclwiIHx8IGlwdjRIb3N0ID09PSBmYWlsdXJlKSB7XHJcbiAgICByZXR1cm4gaXB2NEhvc3Q7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXNjaWlEb21haW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlT3BhcXVlSG9zdChpbnB1dCkge1xyXG4gIGlmIChjb250YWluc0ZvcmJpZGRlbkhvc3RDb2RlUG9pbnRFeGNsdWRpbmdQZXJjZW50KGlucHV0KSkge1xyXG4gICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgfVxyXG5cclxuICBsZXQgb3V0cHV0ID0gXCJcIjtcclxuICBjb25zdCBkZWNvZGVkID0gcHVueWNvZGUudWNzMi5kZWNvZGUoaW5wdXQpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7ICsraSkge1xyXG4gICAgb3V0cHV0ICs9IHBlcmNlbnRFbmNvZGVDaGFyKGRlY29kZWRbaV0sIGlzQzBDb250cm9sUGVyY2VudEVuY29kZSk7XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRMb25nZXN0WmVyb1NlcXVlbmNlKGFycikge1xyXG4gIGxldCBtYXhJZHggPSBudWxsO1xyXG4gIGxldCBtYXhMZW4gPSAxOyAvLyBvbmx5IGZpbmQgZWxlbWVudHMgPiAxXHJcbiAgbGV0IGN1cnJTdGFydCA9IG51bGw7XHJcbiAgbGV0IGN1cnJMZW4gPSAwO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGFycltpXSAhPT0gMCkge1xyXG4gICAgICBpZiAoY3VyckxlbiA+IG1heExlbikge1xyXG4gICAgICAgIG1heElkeCA9IGN1cnJTdGFydDtcclxuICAgICAgICBtYXhMZW4gPSBjdXJyTGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xyXG4gICAgICBjdXJyTGVuID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIHtcclxuICAgICAgICBjdXJyU3RhcnQgPSBpO1xyXG4gICAgICB9XHJcbiAgICAgICsrY3VyckxlbjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGlmIHRyYWlsaW5nIHplcm9zXHJcbiAgaWYgKGN1cnJMZW4gPiBtYXhMZW4pIHtcclxuICAgIG1heElkeCA9IGN1cnJTdGFydDtcclxuICAgIG1heExlbiA9IGN1cnJMZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaWR4OiBtYXhJZHgsXHJcbiAgICBsZW46IG1heExlblxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUhvc3QoaG9zdCkge1xyXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZUlQdjQoaG9zdCk7XHJcbiAgfVxyXG5cclxuICAvLyBJUHY2IHNlcmlhbGl6ZXJcclxuICBpZiAoaG9zdCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICByZXR1cm4gXCJbXCIgKyBzZXJpYWxpemVJUHY2KGhvc3QpICsgXCJdXCI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaG9zdDtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpbUNvbnRyb2xDaGFycyh1cmwpIHtcclxuICByZXR1cm4gdXJsLnJlcGxhY2UoL15bXFx1MDAwMC1cXHUwMDFGXFx1MDAyMF0rfFtcXHUwMDAwLVxcdTAwMUZcXHUwMDIwXSskL2csIFwiXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmltVGFiQW5kTmV3bGluZSh1cmwpIHtcclxuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcdTAwMDl8XFx1MDAwQXxcXHUwMDBEL2csIFwiXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG9ydGVuUGF0aCh1cmwpIHtcclxuICBjb25zdCBwYXRoID0gdXJsLnBhdGg7XHJcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh1cmwuc2NoZW1lID09PSBcImZpbGVcIiAmJiBwYXRoLmxlbmd0aCA9PT0gMSAmJiBpc05vcm1hbGl6ZWRXaW5kb3dzRHJpdmVMZXR0ZXIocGF0aFswXSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHBhdGgucG9wKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluY2x1ZGVzQ3JlZGVudGlhbHModXJsKSB7XHJcbiAgcmV0dXJuIHVybC51c2VybmFtZSAhPT0gXCJcIiB8fCB1cmwucGFzc3dvcmQgIT09IFwiXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbm5vdEhhdmVBVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSB7XHJcbiAgcmV0dXJuIHVybC5ob3N0ID09PSBudWxsIHx8IHVybC5ob3N0ID09PSBcIlwiIHx8IHVybC5jYW5ub3RCZUFCYXNlVVJMIHx8IHVybC5zY2hlbWUgPT09IFwiZmlsZVwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc05vcm1hbGl6ZWRXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIC9eW0EtWmEtel06JC8udGVzdChzdHJpbmcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBVUkxTdGF0ZU1hY2hpbmUoaW5wdXQsIGJhc2UsIGVuY29kaW5nT3ZlcnJpZGUsIHVybCwgc3RhdGVPdmVycmlkZSkge1xyXG4gIHRoaXMucG9pbnRlciA9IDA7XHJcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gIHRoaXMuYmFzZSA9IGJhc2UgfHwgbnVsbDtcclxuICB0aGlzLmVuY29kaW5nT3ZlcnJpZGUgPSBlbmNvZGluZ092ZXJyaWRlIHx8IFwidXRmLThcIjtcclxuICB0aGlzLnN0YXRlT3ZlcnJpZGUgPSBzdGF0ZU92ZXJyaWRlO1xyXG4gIHRoaXMudXJsID0gdXJsO1xyXG4gIHRoaXMuZmFpbHVyZSA9IGZhbHNlO1xyXG4gIHRoaXMucGFyc2VFcnJvciA9IGZhbHNlO1xyXG5cclxuICBpZiAoIXRoaXMudXJsKSB7XHJcbiAgICB0aGlzLnVybCA9IHtcclxuICAgICAgc2NoZW1lOiBcIlwiLFxyXG4gICAgICB1c2VybmFtZTogXCJcIixcclxuICAgICAgcGFzc3dvcmQ6IFwiXCIsXHJcbiAgICAgIGhvc3Q6IG51bGwsXHJcbiAgICAgIHBvcnQ6IG51bGwsXHJcbiAgICAgIHBhdGg6IFtdLFxyXG4gICAgICBxdWVyeTogbnVsbCxcclxuICAgICAgZnJhZ21lbnQ6IG51bGwsXHJcblxyXG4gICAgICBjYW5ub3RCZUFCYXNlVVJMOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByZXMgPSB0cmltQ29udHJvbENoYXJzKHRoaXMuaW5wdXQpO1xyXG4gICAgaWYgKHJlcyAhPT0gdGhpcy5pbnB1dCkge1xyXG4gICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbnB1dCA9IHJlcztcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlcyA9IHRyaW1UYWJBbmROZXdsaW5lKHRoaXMuaW5wdXQpO1xyXG4gIGlmIChyZXMgIT09IHRoaXMuaW5wdXQpIHtcclxuICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgfVxyXG4gIHRoaXMuaW5wdXQgPSByZXM7XHJcblxyXG4gIHRoaXMuc3RhdGUgPSBzdGF0ZU92ZXJyaWRlIHx8IFwic2NoZW1lIHN0YXJ0XCI7XHJcblxyXG4gIHRoaXMuYnVmZmVyID0gXCJcIjtcclxuICB0aGlzLmF0RmxhZyA9IGZhbHNlO1xyXG4gIHRoaXMuYXJyRmxhZyA9IGZhbHNlO1xyXG4gIHRoaXMucGFzc3dvcmRUb2tlblNlZW5GbGFnID0gZmFsc2U7XHJcblxyXG4gIHRoaXMuaW5wdXQgPSBwdW55Y29kZS51Y3MyLmRlY29kZSh0aGlzLmlucHV0KTtcclxuXHJcbiAgZm9yICg7IHRoaXMucG9pbnRlciA8PSB0aGlzLmlucHV0Lmxlbmd0aDsgKyt0aGlzLnBvaW50ZXIpIHtcclxuICAgIGNvbnN0IGMgPSB0aGlzLmlucHV0W3RoaXMucG9pbnRlcl07XHJcbiAgICBjb25zdCBjU3RyID0gaXNOYU4oYykgPyB1bmRlZmluZWQgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcclxuXHJcbiAgICAvLyBleGVjIHN0YXRlIG1hY2hpbmVcclxuICAgIGNvbnN0IHJldCA9IHRoaXNbXCJwYXJzZSBcIiArIHRoaXMuc3RhdGVdKGMsIGNTdHIpO1xyXG4gICAgaWYgKCFyZXQpIHtcclxuICAgICAgYnJlYWs7IC8vIHRlcm1pbmF0ZSBhbGdvcml0aG1cclxuICAgIH0gZWxzZSBpZiAocmV0ID09PSBmYWlsdXJlKSB7XHJcbiAgICAgIHRoaXMuZmFpbHVyZSA9IHRydWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIHNjaGVtZSBzdGFydFwiXSA9IGZ1bmN0aW9uIHBhcnNlU2NoZW1lU3RhcnQoYywgY1N0cikge1xyXG4gIGlmIChpc0FTQ0lJQWxwaGEoYykpIHtcclxuICAgIHRoaXMuYnVmZmVyICs9IGNTdHIudG9Mb3dlckNhc2UoKTtcclxuICAgIHRoaXMuc3RhdGUgPSBcInNjaGVtZVwiO1xyXG4gIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGVPdmVycmlkZSkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwibm8gc2NoZW1lXCI7XHJcbiAgICAtLXRoaXMucG9pbnRlcjtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgIHJldHVybiBmYWlsdXJlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2Ugc2NoZW1lXCJdID0gZnVuY3Rpb24gcGFyc2VTY2hlbWUoYywgY1N0cikge1xyXG4gIGlmIChpc0FTQ0lJQWxwaGFudW1lcmljKGMpIHx8IGMgPT09IDQzIHx8IGMgPT09IDQ1IHx8IGMgPT09IDQ2KSB7XHJcbiAgICB0aGlzLmJ1ZmZlciArPSBjU3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgfSBlbHNlIGlmIChjID09PSA1OCkge1xyXG4gICAgaWYgKHRoaXMuc3RhdGVPdmVycmlkZSkge1xyXG4gICAgICBpZiAoaXNTcGVjaWFsKHRoaXMudXJsKSAmJiAhaXNTcGVjaWFsU2NoZW1lKHRoaXMuYnVmZmVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFpc1NwZWNpYWwodGhpcy51cmwpICYmIGlzU3BlY2lhbFNjaGVtZSh0aGlzLmJ1ZmZlcikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgoaW5jbHVkZXNDcmVkZW50aWFscyh0aGlzLnVybCkgfHwgdGhpcy51cmwucG9ydCAhPT0gbnVsbCkgJiYgdGhpcy5idWZmZXIgPT09IFwiZmlsZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy51cmwuc2NoZW1lID09PSBcImZpbGVcIiAmJiAodGhpcy51cmwuaG9zdCA9PT0gXCJcIiB8fCB0aGlzLnVybC5ob3N0ID09PSBudWxsKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy51cmwuc2NoZW1lID0gdGhpcy5idWZmZXI7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XHJcbiAgICBpZiAodGhpcy5zdGF0ZU92ZXJyaWRlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnVybC5zY2hlbWUgPT09IFwiZmlsZVwiKSB7XHJcbiAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDFdICE9PSA0NyB8fCB0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDJdICE9PSA0Nykge1xyXG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IFwiZmlsZVwiO1xyXG4gICAgfSBlbHNlIGlmIChpc1NwZWNpYWwodGhpcy51cmwpICYmIHRoaXMuYmFzZSAhPT0gbnVsbCAmJiB0aGlzLmJhc2Uuc2NoZW1lID09PSB0aGlzLnVybC5zY2hlbWUpIHtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFwic3BlY2lhbCByZWxhdGl2ZSBvciBhdXRob3JpdHlcIjtcclxuICAgIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHRoaXMudXJsKSkge1xyXG4gICAgICB0aGlzLnN0YXRlID0gXCJzcGVjaWFsIGF1dGhvcml0eSBzbGFzaGVzXCI7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb2ludGVyICsgMV0gPT09IDQ3KSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBcInBhdGggb3IgYXV0aG9yaXR5XCI7XHJcbiAgICAgICsrdGhpcy5wb2ludGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy51cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XHJcbiAgICAgIHRoaXMudXJsLnBhdGgucHVzaChcIlwiKTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFwiY2Fubm90LWJlLWEtYmFzZS1VUkwgcGF0aFwiO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGVPdmVycmlkZSkge1xyXG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwibm8gc2NoZW1lXCI7XHJcbiAgICB0aGlzLnBvaW50ZXIgPSAtMTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgIHJldHVybiBmYWlsdXJlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2Ugbm8gc2NoZW1lXCJdID0gZnVuY3Rpb24gcGFyc2VOb1NjaGVtZShjKSB7XHJcbiAgaWYgKHRoaXMuYmFzZSA9PT0gbnVsbCB8fCAodGhpcy5iYXNlLmNhbm5vdEJlQUJhc2VVUkwgJiYgYyAhPT0gMzUpKSB7XHJcbiAgICByZXR1cm4gZmFpbHVyZTtcclxuICB9IGVsc2UgaWYgKHRoaXMuYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGMgPT09IDM1KSB7XHJcbiAgICB0aGlzLnVybC5zY2hlbWUgPSB0aGlzLmJhc2Uuc2NoZW1lO1xyXG4gICAgdGhpcy51cmwucGF0aCA9IHRoaXMuYmFzZS5wYXRoLnNsaWNlKCk7XHJcbiAgICB0aGlzLnVybC5xdWVyeSA9IHRoaXMuYmFzZS5xdWVyeTtcclxuICAgIHRoaXMudXJsLmZyYWdtZW50ID0gXCJcIjtcclxuICAgIHRoaXMudXJsLmNhbm5vdEJlQUJhc2VVUkwgPSB0cnVlO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiZnJhZ21lbnRcIjtcclxuICB9IGVsc2UgaWYgKHRoaXMuYmFzZS5zY2hlbWUgPT09IFwiZmlsZVwiKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gXCJmaWxlXCI7XHJcbiAgICAtLXRoaXMucG9pbnRlcjtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwicmVsYXRpdmVcIjtcclxuICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2Ugc3BlY2lhbCByZWxhdGl2ZSBvciBhdXRob3JpdHlcIl0gPSBmdW5jdGlvbiBwYXJzZVNwZWNpYWxSZWxhdGl2ZU9yQXV0aG9yaXR5KGMpIHtcclxuICBpZiAoYyA9PT0gNDcgJiYgdGhpcy5pbnB1dFt0aGlzLnBvaW50ZXIgKyAxXSA9PT0gNDcpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBcInNwZWNpYWwgYXV0aG9yaXR5IGlnbm9yZSBzbGFzaGVzXCI7XHJcbiAgICArK3RoaXMucG9pbnRlcjtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgIHRoaXMuc3RhdGUgPSBcInJlbGF0aXZlXCI7XHJcbiAgICAtLXRoaXMucG9pbnRlcjtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIHBhdGggb3IgYXV0aG9yaXR5XCJdID0gZnVuY3Rpb24gcGFyc2VQYXRoT3JBdXRob3JpdHkoYykge1xyXG4gIGlmIChjID09PSA0Nykge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiYXV0aG9yaXR5XCI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuc3RhdGUgPSBcInBhdGhcIjtcclxuICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2UgcmVsYXRpdmVcIl0gPSBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlKGMpIHtcclxuICB0aGlzLnVybC5zY2hlbWUgPSB0aGlzLmJhc2Uuc2NoZW1lO1xyXG4gIGlmIChpc05hTihjKSkge1xyXG4gICAgdGhpcy51cmwudXNlcm5hbWUgPSB0aGlzLmJhc2UudXNlcm5hbWU7XHJcbiAgICB0aGlzLnVybC5wYXNzd29yZCA9IHRoaXMuYmFzZS5wYXNzd29yZDtcclxuICAgIHRoaXMudXJsLmhvc3QgPSB0aGlzLmJhc2UuaG9zdDtcclxuICAgIHRoaXMudXJsLnBvcnQgPSB0aGlzLmJhc2UucG9ydDtcclxuICAgIHRoaXMudXJsLnBhdGggPSB0aGlzLmJhc2UucGF0aC5zbGljZSgpO1xyXG4gICAgdGhpcy51cmwucXVlcnkgPSB0aGlzLmJhc2UucXVlcnk7XHJcbiAgfSBlbHNlIGlmIChjID09PSA0Nykge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwicmVsYXRpdmUgc2xhc2hcIjtcclxuICB9IGVsc2UgaWYgKGMgPT09IDYzKSB7XHJcbiAgICB0aGlzLnVybC51c2VybmFtZSA9IHRoaXMuYmFzZS51c2VybmFtZTtcclxuICAgIHRoaXMudXJsLnBhc3N3b3JkID0gdGhpcy5iYXNlLnBhc3N3b3JkO1xyXG4gICAgdGhpcy51cmwuaG9zdCA9IHRoaXMuYmFzZS5ob3N0O1xyXG4gICAgdGhpcy51cmwucG9ydCA9IHRoaXMuYmFzZS5wb3J0O1xyXG4gICAgdGhpcy51cmwucGF0aCA9IHRoaXMuYmFzZS5wYXRoLnNsaWNlKCk7XHJcbiAgICB0aGlzLnVybC5xdWVyeSA9IFwiXCI7XHJcbiAgICB0aGlzLnN0YXRlID0gXCJxdWVyeVwiO1xyXG4gIH0gZWxzZSBpZiAoYyA9PT0gMzUpIHtcclxuICAgIHRoaXMudXJsLnVzZXJuYW1lID0gdGhpcy5iYXNlLnVzZXJuYW1lO1xyXG4gICAgdGhpcy51cmwucGFzc3dvcmQgPSB0aGlzLmJhc2UucGFzc3dvcmQ7XHJcbiAgICB0aGlzLnVybC5ob3N0ID0gdGhpcy5iYXNlLmhvc3Q7XHJcbiAgICB0aGlzLnVybC5wb3J0ID0gdGhpcy5iYXNlLnBvcnQ7XHJcbiAgICB0aGlzLnVybC5wYXRoID0gdGhpcy5iYXNlLnBhdGguc2xpY2UoKTtcclxuICAgIHRoaXMudXJsLnF1ZXJ5ID0gdGhpcy5iYXNlLnF1ZXJ5O1xyXG4gICAgdGhpcy51cmwuZnJhZ21lbnQgPSBcIlwiO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiZnJhZ21lbnRcIjtcclxuICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh0aGlzLnVybCkgJiYgYyA9PT0gOTIpIHtcclxuICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICB0aGlzLnN0YXRlID0gXCJyZWxhdGl2ZSBzbGFzaFwiO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnVybC51c2VybmFtZSA9IHRoaXMuYmFzZS51c2VybmFtZTtcclxuICAgIHRoaXMudXJsLnBhc3N3b3JkID0gdGhpcy5iYXNlLnBhc3N3b3JkO1xyXG4gICAgdGhpcy51cmwuaG9zdCA9IHRoaXMuYmFzZS5ob3N0O1xyXG4gICAgdGhpcy51cmwucG9ydCA9IHRoaXMuYmFzZS5wb3J0O1xyXG4gICAgdGhpcy51cmwucGF0aCA9IHRoaXMuYmFzZS5wYXRoLnNsaWNlKDAsIHRoaXMuYmFzZS5wYXRoLmxlbmd0aCAtIDEpO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBcInBhdGhcIjtcclxuICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2UgcmVsYXRpdmUgc2xhc2hcIl0gPSBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlU2xhc2goYykge1xyXG4gIGlmIChpc1NwZWNpYWwodGhpcy51cmwpICYmIChjID09PSA0NyB8fCBjID09PSA5MikpIHtcclxuICAgIGlmIChjID09PSA5Mikge1xyXG4gICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdGF0ZSA9IFwic3BlY2lhbCBhdXRob3JpdHkgaWdub3JlIHNsYXNoZXNcIjtcclxuICB9IGVsc2UgaWYgKGMgPT09IDQ3KSB7XHJcbiAgICB0aGlzLnN0YXRlID0gXCJhdXRob3JpdHlcIjtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy51cmwudXNlcm5hbWUgPSB0aGlzLmJhc2UudXNlcm5hbWU7XHJcbiAgICB0aGlzLnVybC5wYXNzd29yZCA9IHRoaXMuYmFzZS5wYXNzd29yZDtcclxuICAgIHRoaXMudXJsLmhvc3QgPSB0aGlzLmJhc2UuaG9zdDtcclxuICAgIHRoaXMudXJsLnBvcnQgPSB0aGlzLmJhc2UucG9ydDtcclxuICAgIHRoaXMuc3RhdGUgPSBcInBhdGhcIjtcclxuICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2Ugc3BlY2lhbCBhdXRob3JpdHkgc2xhc2hlc1wiXSA9IGZ1bmN0aW9uIHBhcnNlU3BlY2lhbEF1dGhvcml0eVNsYXNoZXMoYykge1xyXG4gIGlmIChjID09PSA0NyAmJiB0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDFdID09PSA0Nykge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwic3BlY2lhbCBhdXRob3JpdHkgaWdub3JlIHNsYXNoZXNcIjtcclxuICAgICsrdGhpcy5wb2ludGVyO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwic3BlY2lhbCBhdXRob3JpdHkgaWdub3JlIHNsYXNoZXNcIjtcclxuICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2Ugc3BlY2lhbCBhdXRob3JpdHkgaWdub3JlIHNsYXNoZXNcIl0gPSBmdW5jdGlvbiBwYXJzZVNwZWNpYWxBdXRob3JpdHlJZ25vcmVTbGFzaGVzKGMpIHtcclxuICBpZiAoYyAhPT0gNDcgJiYgYyAhPT0gOTIpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBcImF1dGhvcml0eVwiO1xyXG4gICAgLS10aGlzLnBvaW50ZXI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblVSTFN0YXRlTWFjaGluZS5wcm90b3R5cGVbXCJwYXJzZSBhdXRob3JpdHlcIl0gPSBmdW5jdGlvbiBwYXJzZUF1dGhvcml0eShjLCBjU3RyKSB7XHJcbiAgaWYgKGMgPT09IDY0KSB7XHJcbiAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgaWYgKHRoaXMuYXRGbGFnKSB7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gXCIlNDBcIiArIHRoaXMuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hdEZsYWcgPSB0cnVlO1xyXG5cclxuICAgIC8vIGNhcmVmdWwsIHRoaXMgaXMgYmFzZWQgb24gYnVmZmVyIGFuZCBoYXMgaXRzIG93biBwb2ludGVyICh0aGlzLnBvaW50ZXIgIT0gcG9pbnRlcikgYW5kIGlubmVyIGNoYXJzXHJcbiAgICBjb25zdCBsZW4gPSBjb3VudFN5bWJvbHModGhpcy5idWZmZXIpO1xyXG4gICAgZm9yIChsZXQgcG9pbnRlciA9IDA7IHBvaW50ZXIgPCBsZW47ICsrcG9pbnRlcikge1xyXG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSB0aGlzLmJ1ZmZlci5jb2RlUG9pbnRBdChwb2ludGVyKTtcclxuXHJcbiAgICAgIGlmIChjb2RlUG9pbnQgPT09IDU4ICYmICF0aGlzLnBhc3N3b3JkVG9rZW5TZWVuRmxhZykge1xyXG4gICAgICAgIHRoaXMucGFzc3dvcmRUb2tlblNlZW5GbGFnID0gdHJ1ZTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbmNvZGVkQ29kZVBvaW50cyA9IHBlcmNlbnRFbmNvZGVDaGFyKGNvZGVQb2ludCwgaXNVc2VyaW5mb1BlcmNlbnRFbmNvZGUpO1xyXG4gICAgICBpZiAodGhpcy5wYXNzd29yZFRva2VuU2VlbkZsYWcpIHtcclxuICAgICAgICB0aGlzLnVybC5wYXNzd29yZCArPSBlbmNvZGVkQ29kZVBvaW50cztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVybC51c2VybmFtZSArPSBlbmNvZGVkQ29kZVBvaW50cztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gIH0gZWxzZSBpZiAoaXNOYU4oYykgfHwgYyA9PT0gNDcgfHwgYyA9PT0gNjMgfHwgYyA9PT0gMzUgfHxcclxuICAgICAgICAgICAgIChpc1NwZWNpYWwodGhpcy51cmwpICYmIGMgPT09IDkyKSkge1xyXG4gICAgaWYgKHRoaXMuYXRGbGFnICYmIHRoaXMuYnVmZmVyID09PSBcIlwiKSB7XHJcbiAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wb2ludGVyIC09IGNvdW50U3ltYm9scyh0aGlzLmJ1ZmZlcikgKyAxO1xyXG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiaG9zdFwiO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmJ1ZmZlciArPSBjU3RyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2UgaG9zdG5hbWVcIl0gPVxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2UgaG9zdFwiXSA9IGZ1bmN0aW9uIHBhcnNlSG9zdE5hbWUoYywgY1N0cikge1xyXG4gIGlmICh0aGlzLnN0YXRlT3ZlcnJpZGUgJiYgdGhpcy51cmwuc2NoZW1lID09PSBcImZpbGVcIikge1xyXG4gICAgLS10aGlzLnBvaW50ZXI7XHJcbiAgICB0aGlzLnN0YXRlID0gXCJmaWxlIGhvc3RcIjtcclxuICB9IGVsc2UgaWYgKGMgPT09IDU4ICYmICF0aGlzLmFyckZsYWcpIHtcclxuICAgIGlmICh0aGlzLmJ1ZmZlciA9PT0gXCJcIikge1xyXG4gICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFpbHVyZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBob3N0ID0gcGFyc2VIb3N0KHRoaXMuYnVmZmVyLCBpc1NwZWNpYWwodGhpcy51cmwpKTtcclxuICAgIGlmIChob3N0ID09PSBmYWlsdXJlKSB7XHJcbiAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXJsLmhvc3QgPSBob3N0O1xyXG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwicG9ydFwiO1xyXG4gICAgaWYgKHRoaXMuc3RhdGVPdmVycmlkZSA9PT0gXCJob3N0bmFtZVwiKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzTmFOKGMpIHx8IGMgPT09IDQ3IHx8IGMgPT09IDYzIHx8IGMgPT09IDM1IHx8XHJcbiAgICAgICAgICAgICAoaXNTcGVjaWFsKHRoaXMudXJsKSAmJiBjID09PSA5MikpIHtcclxuICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gICAgaWYgKGlzU3BlY2lhbCh0aGlzLnVybCkgJiYgdGhpcy5idWZmZXIgPT09IFwiXCIpIHtcclxuICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGVPdmVycmlkZSAmJiB0aGlzLmJ1ZmZlciA9PT0gXCJcIiAmJlxyXG4gICAgICAgICAgICAgICAoaW5jbHVkZXNDcmVkZW50aWFscyh0aGlzLnVybCkgfHwgdGhpcy51cmwucG9ydCAhPT0gbnVsbCkpIHtcclxuICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhvc3QgPSBwYXJzZUhvc3QodGhpcy5idWZmZXIsIGlzU3BlY2lhbCh0aGlzLnVybCkpO1xyXG4gICAgaWYgKGhvc3QgPT09IGZhaWx1cmUpIHtcclxuICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cmwuaG9zdCA9IGhvc3Q7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XHJcbiAgICB0aGlzLnN0YXRlID0gXCJwYXRoIHN0YXJ0XCI7XHJcbiAgICBpZiAodGhpcy5zdGF0ZU92ZXJyaWRlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGMgPT09IDkxKSB7XHJcbiAgICAgIHRoaXMuYXJyRmxhZyA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDkzKSB7XHJcbiAgICAgIHRoaXMuYXJyRmxhZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5idWZmZXIgKz0gY1N0cjtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIHBvcnRcIl0gPSBmdW5jdGlvbiBwYXJzZVBvcnQoYywgY1N0cikge1xyXG4gIGlmIChpc0FTQ0lJRGlnaXQoYykpIHtcclxuICAgIHRoaXMuYnVmZmVyICs9IGNTdHI7XHJcbiAgfSBlbHNlIGlmIChpc05hTihjKSB8fCBjID09PSA0NyB8fCBjID09PSA2MyB8fCBjID09PSAzNSB8fFxyXG4gICAgICAgICAgICAgKGlzU3BlY2lhbCh0aGlzLnVybCkgJiYgYyA9PT0gOTIpIHx8XHJcbiAgICAgICAgICAgICB0aGlzLnN0YXRlT3ZlcnJpZGUpIHtcclxuICAgIGlmICh0aGlzLmJ1ZmZlciAhPT0gXCJcIikge1xyXG4gICAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQodGhpcy5idWZmZXIpO1xyXG4gICAgICBpZiAocG9ydCA+IE1hdGgucG93KDIsIDE2KSAtIDEpIHtcclxuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBmYWlsdXJlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXJsLnBvcnQgPSBwb3J0ID09PSBkZWZhdWx0UG9ydCh0aGlzLnVybC5zY2hlbWUpID8gbnVsbCA6IHBvcnQ7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN0YXRlT3ZlcnJpZGUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdGF0ZSA9IFwicGF0aCBzdGFydFwiO1xyXG4gICAgLS10aGlzLnBvaW50ZXI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICByZXR1cm4gZmFpbHVyZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuY29uc3QgZmlsZU90aGVyd2lzZUNvZGVQb2ludHMgPSBuZXcgU2V0KFs0NywgOTIsIDYzLCAzNV0pO1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIGZpbGVcIl0gPSBmdW5jdGlvbiBwYXJzZUZpbGUoYykge1xyXG4gIHRoaXMudXJsLnNjaGVtZSA9IFwiZmlsZVwiO1xyXG5cclxuICBpZiAoYyA9PT0gNDcgfHwgYyA9PT0gOTIpIHtcclxuICAgIGlmIChjID09PSA5Mikge1xyXG4gICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdGF0ZSA9IFwiZmlsZSBzbGFzaFwiO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5iYXNlICE9PSBudWxsICYmIHRoaXMuYmFzZS5zY2hlbWUgPT09IFwiZmlsZVwiKSB7XHJcbiAgICBpZiAoaXNOYU4oYykpIHtcclxuICAgICAgdGhpcy51cmwuaG9zdCA9IHRoaXMuYmFzZS5ob3N0O1xyXG4gICAgICB0aGlzLnVybC5wYXRoID0gdGhpcy5iYXNlLnBhdGguc2xpY2UoKTtcclxuICAgICAgdGhpcy51cmwucXVlcnkgPSB0aGlzLmJhc2UucXVlcnk7XHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IDYzKSB7XHJcbiAgICAgIHRoaXMudXJsLmhvc3QgPSB0aGlzLmJhc2UuaG9zdDtcclxuICAgICAgdGhpcy51cmwucGF0aCA9IHRoaXMuYmFzZS5wYXRoLnNsaWNlKCk7XHJcbiAgICAgIHRoaXMudXJsLnF1ZXJ5ID0gXCJcIjtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFwicXVlcnlcIjtcclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gMzUpIHtcclxuICAgICAgdGhpcy51cmwuaG9zdCA9IHRoaXMuYmFzZS5ob3N0O1xyXG4gICAgICB0aGlzLnVybC5wYXRoID0gdGhpcy5iYXNlLnBhdGguc2xpY2UoKTtcclxuICAgICAgdGhpcy51cmwucXVlcnkgPSB0aGlzLmJhc2UucXVlcnk7XHJcbiAgICAgIHRoaXMudXJsLmZyYWdtZW50ID0gXCJcIjtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFwiZnJhZ21lbnRcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLmlucHV0Lmxlbmd0aCAtIHRoaXMucG9pbnRlciAtIDEgPT09IDAgfHwgLy8gcmVtYWluaW5nIGNvbnNpc3RzIG9mIDAgY29kZSBwb2ludHNcclxuICAgICAgICAgICFpc1dpbmRvd3NEcml2ZUxldHRlckNvZGVQb2ludHMoYywgdGhpcy5pbnB1dFt0aGlzLnBvaW50ZXIgKyAxXSkgfHxcclxuICAgICAgICAgICh0aGlzLmlucHV0Lmxlbmd0aCAtIHRoaXMucG9pbnRlciAtIDEgPj0gMiAmJiAvLyByZW1haW5pbmcgaGFzIGF0IGxlYXN0IDIgY29kZSBwb2ludHNcclxuICAgICAgICAgICAhZmlsZU90aGVyd2lzZUNvZGVQb2ludHMuaGFzKHRoaXMuaW5wdXRbdGhpcy5wb2ludGVyICsgMl0pKSkge1xyXG4gICAgICAgIHRoaXMudXJsLmhvc3QgPSB0aGlzLmJhc2UuaG9zdDtcclxuICAgICAgICB0aGlzLnVybC5wYXRoID0gdGhpcy5iYXNlLnBhdGguc2xpY2UoKTtcclxuICAgICAgICBzaG9ydGVuUGF0aCh0aGlzLnVybCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGF0ZSA9IFwicGF0aFwiO1xyXG4gICAgICAtLXRoaXMucG9pbnRlcjtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwicGF0aFwiO1xyXG4gICAgLS10aGlzLnBvaW50ZXI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblVSTFN0YXRlTWFjaGluZS5wcm90b3R5cGVbXCJwYXJzZSBmaWxlIHNsYXNoXCJdID0gZnVuY3Rpb24gcGFyc2VGaWxlU2xhc2goYykge1xyXG4gIGlmIChjID09PSA0NyB8fCBjID09PSA5Mikge1xyXG4gICAgaWYgKGMgPT09IDkyKSB7XHJcbiAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXRlID0gXCJmaWxlIGhvc3RcIjtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHRoaXMuYmFzZSAhPT0gbnVsbCAmJiB0aGlzLmJhc2Uuc2NoZW1lID09PSBcImZpbGVcIikge1xyXG4gICAgICBpZiAoaXNOb3JtYWxpemVkV2luZG93c0RyaXZlTGV0dGVyU3RyaW5nKHRoaXMuYmFzZS5wYXRoWzBdKSkge1xyXG4gICAgICAgIHRoaXMudXJsLnBhdGgucHVzaCh0aGlzLmJhc2UucGF0aFswXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51cmwuaG9zdCA9IHRoaXMuYmFzZS5ob3N0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXRlID0gXCJwYXRoXCI7XHJcbiAgICAtLXRoaXMucG9pbnRlcjtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIGZpbGUgaG9zdFwiXSA9IGZ1bmN0aW9uIHBhcnNlRmlsZUhvc3QoYywgY1N0cikge1xyXG4gIGlmIChpc05hTihjKSB8fCBjID09PSA0NyB8fCBjID09PSA5MiB8fCBjID09PSA2MyB8fCBjID09PSAzNSkge1xyXG4gICAgLS10aGlzLnBvaW50ZXI7XHJcbiAgICBpZiAoIXRoaXMuc3RhdGVPdmVycmlkZSAmJiBpc1dpbmRvd3NEcml2ZUxldHRlclN0cmluZyh0aGlzLmJ1ZmZlcikpIHtcclxuICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFwicGF0aFwiO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1ZmZlciA9PT0gXCJcIikge1xyXG4gICAgICB0aGlzLnVybC5ob3N0ID0gXCJcIjtcclxuICAgICAgaWYgKHRoaXMuc3RhdGVPdmVycmlkZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnN0YXRlID0gXCJwYXRoIHN0YXJ0XCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgaG9zdCA9IHBhcnNlSG9zdCh0aGlzLmJ1ZmZlciwgaXNTcGVjaWFsKHRoaXMudXJsKSk7XHJcbiAgICAgIGlmIChob3N0ID09PSBmYWlsdXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGhvc3QgPT09IFwibG9jYWxob3N0XCIpIHtcclxuICAgICAgICBob3N0ID0gXCJcIjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVybC5ob3N0ID0gaG9zdDtcclxuXHJcbiAgICAgIGlmICh0aGlzLnN0YXRlT3ZlcnJpZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcclxuICAgICAgdGhpcy5zdGF0ZSA9IFwicGF0aCBzdGFydFwiO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmJ1ZmZlciArPSBjU3RyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5VUkxTdGF0ZU1hY2hpbmUucHJvdG90eXBlW1wicGFyc2UgcGF0aCBzdGFydFwiXSA9IGZ1bmN0aW9uIHBhcnNlUGF0aFN0YXJ0KGMpIHtcclxuICBpZiAoaXNTcGVjaWFsKHRoaXMudXJsKSkge1xyXG4gICAgaWYgKGMgPT09IDkyKSB7XHJcbiAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXRlID0gXCJwYXRoXCI7XHJcblxyXG4gICAgaWYgKGMgIT09IDQ3ICYmIGMgIT09IDkyKSB7XHJcbiAgICAgIC0tdGhpcy5wb2ludGVyO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGVPdmVycmlkZSAmJiBjID09PSA2Mykge1xyXG4gICAgdGhpcy51cmwucXVlcnkgPSBcIlwiO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwicXVlcnlcIjtcclxuICB9IGVsc2UgaWYgKCF0aGlzLnN0YXRlT3ZlcnJpZGUgJiYgYyA9PT0gMzUpIHtcclxuICAgIHRoaXMudXJsLmZyYWdtZW50ID0gXCJcIjtcclxuICAgIHRoaXMuc3RhdGUgPSBcImZyYWdtZW50XCI7XHJcbiAgfSBlbHNlIGlmIChjICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBcInBhdGhcIjtcclxuICAgIGlmIChjICE9PSA0Nykge1xyXG4gICAgICAtLXRoaXMucG9pbnRlcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIHBhdGhcIl0gPSBmdW5jdGlvbiBwYXJzZVBhdGgoYykge1xyXG4gIGlmIChpc05hTihjKSB8fCBjID09PSA0NyB8fCAoaXNTcGVjaWFsKHRoaXMudXJsKSAmJiBjID09PSA5MikgfHxcclxuICAgICAgKCF0aGlzLnN0YXRlT3ZlcnJpZGUgJiYgKGMgPT09IDYzIHx8IGMgPT09IDM1KSkpIHtcclxuICAgIGlmIChpc1NwZWNpYWwodGhpcy51cmwpICYmIGMgPT09IDkyKSB7XHJcbiAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRG91YmxlRG90KHRoaXMuYnVmZmVyKSkge1xyXG4gICAgICBzaG9ydGVuUGF0aCh0aGlzLnVybCk7XHJcbiAgICAgIGlmIChjICE9PSA0NyAmJiAhKGlzU3BlY2lhbCh0aGlzLnVybCkgJiYgYyA9PT0gOTIpKSB7XHJcbiAgICAgICAgdGhpcy51cmwucGF0aC5wdXNoKFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzU2luZ2xlRG90KHRoaXMuYnVmZmVyKSAmJiBjICE9PSA0NyAmJlxyXG4gICAgICAgICAgICAgICAhKGlzU3BlY2lhbCh0aGlzLnVybCkgJiYgYyA9PT0gOTIpKSB7XHJcbiAgICAgIHRoaXMudXJsLnBhdGgucHVzaChcIlwiKTtcclxuICAgIH0gZWxzZSBpZiAoIWlzU2luZ2xlRG90KHRoaXMuYnVmZmVyKSkge1xyXG4gICAgICBpZiAodGhpcy51cmwuc2NoZW1lID09PSBcImZpbGVcIiAmJiB0aGlzLnVybC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlclN0cmluZyh0aGlzLmJ1ZmZlcikpIHtcclxuICAgICAgICBpZiAodGhpcy51cmwuaG9zdCAhPT0gXCJcIiAmJiB0aGlzLnVybC5ob3N0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy51cmwuaG9zdCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXJbMF0gKyBcIjpcIjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVybC5wYXRoLnB1c2godGhpcy5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gICAgaWYgKHRoaXMudXJsLnNjaGVtZSA9PT0gXCJmaWxlXCIgJiYgKGMgPT09IHVuZGVmaW5lZCB8fCBjID09PSA2MyB8fCBjID09PSAzNSkpIHtcclxuICAgICAgd2hpbGUgKHRoaXMudXJsLnBhdGgubGVuZ3RoID4gMSAmJiB0aGlzLnVybC5wYXRoWzBdID09PSBcIlwiKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnVybC5wYXRoLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjID09PSA2Mykge1xyXG4gICAgICB0aGlzLnVybC5xdWVyeSA9IFwiXCI7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBcInF1ZXJ5XCI7XHJcbiAgICB9XHJcbiAgICBpZiAoYyA9PT0gMzUpIHtcclxuICAgICAgdGhpcy51cmwuZnJhZ21lbnQgPSBcIlwiO1xyXG4gICAgICB0aGlzLnN0YXRlID0gXCJmcmFnbWVudFwiO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBUT0RPOiBJZiBjIGlzIG5vdCBhIFVSTCBjb2RlIHBvaW50IGFuZCBub3QgXCIlXCIsIHBhcnNlIGVycm9yLlxyXG5cclxuICAgIGlmIChjID09PSAzNyAmJlxyXG4gICAgICAoIWlzQVNDSUlIZXgodGhpcy5pbnB1dFt0aGlzLnBvaW50ZXIgKyAxXSkgfHxcclxuICAgICAgICAhaXNBU0NJSUhleCh0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDJdKSkpIHtcclxuICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmJ1ZmZlciArPSBwZXJjZW50RW5jb2RlQ2hhcihjLCBpc1BhdGhQZXJjZW50RW5jb2RlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIGNhbm5vdC1iZS1hLWJhc2UtVVJMIHBhdGhcIl0gPSBmdW5jdGlvbiBwYXJzZUNhbm5vdEJlQUJhc2VVUkxQYXRoKGMpIHtcclxuICBpZiAoYyA9PT0gNjMpIHtcclxuICAgIHRoaXMudXJsLnF1ZXJ5ID0gXCJcIjtcclxuICAgIHRoaXMuc3RhdGUgPSBcInF1ZXJ5XCI7XHJcbiAgfSBlbHNlIGlmIChjID09PSAzNSkge1xyXG4gICAgdGhpcy51cmwuZnJhZ21lbnQgPSBcIlwiO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiZnJhZ21lbnRcIjtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gVE9ETzogQWRkOiBub3QgYSBVUkwgY29kZSBwb2ludFxyXG4gICAgaWYgKCFpc05hTihjKSAmJiBjICE9PSAzNykge1xyXG4gICAgICB0aGlzLnBhcnNlRXJyb3IgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjID09PSAzNyAmJlxyXG4gICAgICAgICghaXNBU0NJSUhleCh0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDFdKSB8fFxyXG4gICAgICAgICAhaXNBU0NJSUhleCh0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDJdKSkpIHtcclxuICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTmFOKGMpKSB7XHJcbiAgICAgIHRoaXMudXJsLnBhdGhbMF0gPSB0aGlzLnVybC5wYXRoWzBdICsgcGVyY2VudEVuY29kZUNoYXIoYywgaXNDMENvbnRyb2xQZXJjZW50RW5jb2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIHF1ZXJ5XCJdID0gZnVuY3Rpb24gcGFyc2VRdWVyeShjLCBjU3RyKSB7XHJcbiAgaWYgKGlzTmFOKGMpIHx8ICghdGhpcy5zdGF0ZU92ZXJyaWRlICYmIGMgPT09IDM1KSkge1xyXG4gICAgaWYgKCFpc1NwZWNpYWwodGhpcy51cmwpIHx8IHRoaXMudXJsLnNjaGVtZSA9PT0gXCJ3c1wiIHx8IHRoaXMudXJsLnNjaGVtZSA9PT0gXCJ3c3NcIikge1xyXG4gICAgICB0aGlzLmVuY29kaW5nT3ZlcnJpZGUgPSBcInV0Zi04XCI7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzLmJ1ZmZlcik7IC8vIFRPRE86IFVzZSBlbmNvZGluZyBvdmVycmlkZSBpbnN0ZWFkXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xyXG4gICAgICBpZiAoYnVmZmVyW2ldIDwgMHgyMSB8fCBidWZmZXJbaV0gPiAweDdFIHx8IGJ1ZmZlcltpXSA9PT0gMHgyMiB8fCBidWZmZXJbaV0gPT09IDB4MjMgfHxcclxuICAgICAgICAgIGJ1ZmZlcltpXSA9PT0gMHgzQyB8fCBidWZmZXJbaV0gPT09IDB4M0UpIHtcclxuICAgICAgICB0aGlzLnVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGJ1ZmZlcltpXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51cmwucXVlcnkgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYnVmZmVyW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcclxuICAgIGlmIChjID09PSAzNSkge1xyXG4gICAgICB0aGlzLnVybC5mcmFnbWVudCA9IFwiXCI7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSBcImZyYWdtZW50XCI7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFRPRE86IElmIGMgaXMgbm90IGEgVVJMIGNvZGUgcG9pbnQgYW5kIG5vdCBcIiVcIiwgcGFyc2UgZXJyb3IuXHJcbiAgICBpZiAoYyA9PT0gMzcgJiZcclxuICAgICAgKCFpc0FTQ0lJSGV4KHRoaXMuaW5wdXRbdGhpcy5wb2ludGVyICsgMV0pIHx8XHJcbiAgICAgICAgIWlzQVNDSUlIZXgodGhpcy5pbnB1dFt0aGlzLnBvaW50ZXIgKyAyXSkpKSB7XHJcbiAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5idWZmZXIgKz0gY1N0cjtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuVVJMU3RhdGVNYWNoaW5lLnByb3RvdHlwZVtcInBhcnNlIGZyYWdtZW50XCJdID0gZnVuY3Rpb24gcGFyc2VGcmFnbWVudChjKSB7XHJcbiAgaWYgKGlzTmFOKGMpKSB7IC8vIGRvIG5vdGhpbmdcclxuICB9IGVsc2UgaWYgKGMgPT09IDB4MCkge1xyXG4gICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gVE9ETzogSWYgYyBpcyBub3QgYSBVUkwgY29kZSBwb2ludCBhbmQgbm90IFwiJVwiLCBwYXJzZSBlcnJvci5cclxuICAgIGlmIChjID09PSAzNyAmJlxyXG4gICAgICAoIWlzQVNDSUlIZXgodGhpcy5pbnB1dFt0aGlzLnBvaW50ZXIgKyAxXSkgfHxcclxuICAgICAgICAhaXNBU0NJSUhleCh0aGlzLmlucHV0W3RoaXMucG9pbnRlciArIDJdKSkpIHtcclxuICAgICAgdGhpcy5wYXJzZUVycm9yID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVybC5mcmFnbWVudCArPSBwZXJjZW50RW5jb2RlQ2hhcihjLCBpc0MwQ29udHJvbFBlcmNlbnRFbmNvZGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemVVUkwodXJsLCBleGNsdWRlRnJhZ21lbnQpIHtcclxuICBsZXQgb3V0cHV0ID0gdXJsLnNjaGVtZSArIFwiOlwiO1xyXG4gIGlmICh1cmwuaG9zdCAhPT0gbnVsbCkge1xyXG4gICAgb3V0cHV0ICs9IFwiLy9cIjtcclxuXHJcbiAgICBpZiAodXJsLnVzZXJuYW1lICE9PSBcIlwiIHx8IHVybC5wYXNzd29yZCAhPT0gXCJcIikge1xyXG4gICAgICBvdXRwdXQgKz0gdXJsLnVzZXJuYW1lO1xyXG4gICAgICBpZiAodXJsLnBhc3N3b3JkICE9PSBcIlwiKSB7XHJcbiAgICAgICAgb3V0cHV0ICs9IFwiOlwiICsgdXJsLnBhc3N3b3JkO1xyXG4gICAgICB9XHJcbiAgICAgIG91dHB1dCArPSBcIkBcIjtcclxuICAgIH1cclxuXHJcbiAgICBvdXRwdXQgKz0gc2VyaWFsaXplSG9zdCh1cmwuaG9zdCk7XHJcblxyXG4gICAgaWYgKHVybC5wb3J0ICE9PSBudWxsKSB7XHJcbiAgICAgIG91dHB1dCArPSBcIjpcIiArIHVybC5wb3J0O1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodXJsLmhvc3QgPT09IG51bGwgJiYgdXJsLnNjaGVtZSA9PT0gXCJmaWxlXCIpIHtcclxuICAgIG91dHB1dCArPSBcIi8vXCI7XHJcbiAgfVxyXG5cclxuICBpZiAodXJsLmNhbm5vdEJlQUJhc2VVUkwpIHtcclxuICAgIG91dHB1dCArPSB1cmwucGF0aFswXTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm9yIChjb25zdCBzdHJpbmcgb2YgdXJsLnBhdGgpIHtcclxuICAgICAgb3V0cHV0ICs9IFwiL1wiICsgc3RyaW5nO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHVybC5xdWVyeSAhPT0gbnVsbCkge1xyXG4gICAgb3V0cHV0ICs9IFwiP1wiICsgdXJsLnF1ZXJ5O1xyXG4gIH1cclxuXHJcbiAgaWYgKCFleGNsdWRlRnJhZ21lbnQgJiYgdXJsLmZyYWdtZW50ICE9PSBudWxsKSB7XHJcbiAgICBvdXRwdXQgKz0gXCIjXCIgKyB1cmwuZnJhZ21lbnQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpYWxpemVPcmlnaW4odHVwbGUpIHtcclxuICBsZXQgcmVzdWx0ID0gdHVwbGUuc2NoZW1lICsgXCI6Ly9cIjtcclxuICByZXN1bHQgKz0gc2VyaWFsaXplSG9zdCh0dXBsZS5ob3N0KTtcclxuXHJcbiAgaWYgKHR1cGxlLnBvcnQgIT09IG51bGwpIHtcclxuICAgIHJlc3VsdCArPSBcIjpcIiArIHR1cGxlLnBvcnQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVVUkwgPSBzZXJpYWxpemVVUkw7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVVUkxPcmlnaW4gPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1vcmlnaW5cclxuICBzd2l0Y2ggKHVybC5zY2hlbWUpIHtcclxuICAgIGNhc2UgXCJibG9iXCI6XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZVVSTE9yaWdpbihtb2R1bGUuZXhwb3J0cy5wYXJzZVVSTCh1cmwucGF0aFswXSkpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gc2VyaWFsaXppbmcgYW4gb3BhcXVlIG9yaWdpbiByZXR1cm5zIFwibnVsbFwiXHJcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgICB9XHJcbiAgICBjYXNlIFwiZnRwXCI6XHJcbiAgICBjYXNlIFwiZ29waGVyXCI6XHJcbiAgICBjYXNlIFwiaHR0cFwiOlxyXG4gICAgY2FzZSBcImh0dHBzXCI6XHJcbiAgICBjYXNlIFwid3NcIjpcclxuICAgIGNhc2UgXCJ3c3NcIjpcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9yaWdpbih7XHJcbiAgICAgICAgc2NoZW1lOiB1cmwuc2NoZW1lLFxyXG4gICAgICAgIGhvc3Q6IHVybC5ob3N0LFxyXG4gICAgICAgIHBvcnQ6IHVybC5wb3J0XHJcbiAgICAgIH0pO1xyXG4gICAgY2FzZSBcImZpbGVcIjpcclxuICAgICAgLy8gc3BlYyBzYXlzIFwiZXhlcmNpc2UgdG8gdGhlIHJlYWRlclwiLCBjaHJvbWUgc2F5cyBcImZpbGU6Ly9cIlxyXG4gICAgICByZXR1cm4gXCJmaWxlOi8vXCI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyBzZXJpYWxpemluZyBhbiBvcGFxdWUgb3JpZ2luIHJldHVybnMgXCJudWxsXCJcclxuICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmJhc2ljVVJMUGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgfVxyXG5cclxuICBjb25zdCB1c20gPSBuZXcgVVJMU3RhdGVNYWNoaW5lKGlucHV0LCBvcHRpb25zLmJhc2VVUkwsIG9wdGlvbnMuZW5jb2RpbmdPdmVycmlkZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuc3RhdGVPdmVycmlkZSk7XHJcbiAgaWYgKHVzbS5mYWlsdXJlKSB7XHJcbiAgICByZXR1cm4gXCJmYWlsdXJlXCI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdXNtLnVybDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnNldFRoZVVzZXJuYW1lID0gZnVuY3Rpb24gKHVybCwgdXNlcm5hbWUpIHtcclxuICB1cmwudXNlcm5hbWUgPSBcIlwiO1xyXG4gIGNvbnN0IGRlY29kZWQgPSBwdW55Y29kZS51Y3MyLmRlY29kZSh1c2VybmFtZSk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7XHJcbiAgICB1cmwudXNlcm5hbWUgKz0gcGVyY2VudEVuY29kZUNoYXIoZGVjb2RlZFtpXSwgaXNVc2VyaW5mb1BlcmNlbnRFbmNvZGUpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnNldFRoZVBhc3N3b3JkID0gZnVuY3Rpb24gKHVybCwgcGFzc3dvcmQpIHtcclxuICB1cmwucGFzc3dvcmQgPSBcIlwiO1xyXG4gIGNvbnN0IGRlY29kZWQgPSBwdW55Y29kZS51Y3MyLmRlY29kZShwYXNzd29yZCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7XHJcbiAgICB1cmwucGFzc3dvcmQgKz0gcGVyY2VudEVuY29kZUNoYXIoZGVjb2RlZFtpXSwgaXNVc2VyaW5mb1BlcmNlbnRFbmNvZGUpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZUhvc3QgPSBzZXJpYWxpemVIb3N0O1xyXG5cclxubW9kdWxlLmV4cG9ydHMuY2Fubm90SGF2ZUFVc2VybmFtZVBhc3N3b3JkUG9ydCA9IGNhbm5vdEhhdmVBVXNlcm5hbWVQYXNzd29yZFBvcnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVJbnRlZ2VyID0gZnVuY3Rpb24gKGludGVnZXIpIHtcclxuICByZXR1cm4gU3RyaW5nKGludGVnZXIpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMucGFyc2VVUkwgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgfVxyXG5cclxuICAvLyBXZSBkb24ndCBoYW5kbGUgYmxvYnMsIHNvIHRoaXMganVzdCBkZWxlZ2F0ZXM6XHJcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmJhc2ljVVJMUGFyc2UoaW5wdXQsIHsgYmFzZVVSTDogb3B0aW9ucy5iYXNlVVJMLCBlbmNvZGluZ092ZXJyaWRlOiBvcHRpb25zLmVuY29kaW5nT3ZlcnJpZGUgfSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJwdW55Y29kZSIsInJlcXVpcmUiLCJ0cjQ2Iiwic3BlY2lhbFNjaGVtZXMiLCJmdHAiLCJmaWxlIiwiZ29waGVyIiwiaHR0cCIsImh0dHBzIiwid3MiLCJ3c3MiLCJmYWlsdXJlIiwiU3ltYm9sIiwiY291bnRTeW1ib2xzIiwic3RyIiwidWNzMiIsImRlY29kZSIsImxlbmd0aCIsImF0IiwiaW5wdXQiLCJpZHgiLCJjIiwiaXNOYU4iLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiaXNBU0NJSURpZ2l0IiwiaXNBU0NJSUFscGhhIiwiaXNBU0NJSUFscGhhbnVtZXJpYyIsImlzQVNDSUlIZXgiLCJpc1NpbmdsZURvdCIsImJ1ZmZlciIsInRvTG93ZXJDYXNlIiwiaXNEb3VibGVEb3QiLCJpc1dpbmRvd3NEcml2ZUxldHRlckNvZGVQb2ludHMiLCJjcDEiLCJjcDIiLCJpc1dpbmRvd3NEcml2ZUxldHRlclN0cmluZyIsInN0cmluZyIsImNvZGVQb2ludEF0IiwiaXNOb3JtYWxpemVkV2luZG93c0RyaXZlTGV0dGVyU3RyaW5nIiwiY29udGFpbnNGb3JiaWRkZW5Ib3N0Q29kZVBvaW50Iiwic2VhcmNoIiwiY29udGFpbnNGb3JiaWRkZW5Ib3N0Q29kZVBvaW50RXhjbHVkaW5nUGVyY2VudCIsImlzU3BlY2lhbFNjaGVtZSIsInNjaGVtZSIsImlzU3BlY2lhbCIsInVybCIsImRlZmF1bHRQb3J0IiwicGVyY2VudEVuY29kZSIsImhleCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJ1dGY4UGVyY2VudEVuY29kZSIsImJ1ZiIsIkJ1ZmZlciIsImkiLCJ1dGY4UGVyY2VudERlY29kZSIsIm91dHB1dCIsInB1c2giLCJwYXJzZUludCIsInNsaWNlIiwiaXNDMENvbnRyb2xQZXJjZW50RW5jb2RlIiwiZXh0cmFQYXRoUGVyY2VudEVuY29kZVNldCIsIlNldCIsImlzUGF0aFBlcmNlbnRFbmNvZGUiLCJoYXMiLCJleHRyYVVzZXJpbmZvUGVyY2VudEVuY29kZVNldCIsImlzVXNlcmluZm9QZXJjZW50RW5jb2RlIiwicGVyY2VudEVuY29kZUNoYXIiLCJlbmNvZGVTZXRQcmVkaWNhdGUiLCJjU3RyIiwicGFyc2VJUHY0TnVtYmVyIiwiUiIsImNoYXJBdCIsInN1YnN0cmluZyIsInJlZ2V4IiwidGVzdCIsInBhcnNlSVB2NCIsInBhcnRzIiwic3BsaXQiLCJwb3AiLCJudW1iZXJzIiwicGFydCIsIm4iLCJNYXRoIiwicG93IiwiaXB2NCIsImNvdW50ZXIiLCJzZXJpYWxpemVJUHY0IiwiYWRkcmVzcyIsImZsb29yIiwicGFyc2VJUHY2IiwicGllY2VJbmRleCIsImNvbXByZXNzIiwicG9pbnRlciIsInZhbHVlIiwibnVtYmVyc1NlZW4iLCJpcHY0UGllY2UiLCJudW1iZXIiLCJzd2FwcyIsInRlbXAiLCJzZXJpYWxpemVJUHY2Iiwic2VxUmVzdWx0IiwiZmluZExvbmdlc3RaZXJvU2VxdWVuY2UiLCJpZ25vcmUwIiwic2VwYXJhdG9yIiwicGFyc2VIb3N0IiwiaXNTcGVjaWFsQXJnIiwicGFyc2VPcGFxdWVIb3N0IiwiZG9tYWluIiwiYXNjaWlEb21haW4iLCJ0b0FTQ0lJIiwiUFJPQ0VTU0lOR19PUFRJT05TIiwiTk9OVFJBTlNJVElPTkFMIiwiaXB2NEhvc3QiLCJkZWNvZGVkIiwiYXJyIiwibWF4SWR4IiwibWF4TGVuIiwiY3VyclN0YXJ0IiwiY3VyckxlbiIsImxlbiIsInNlcmlhbGl6ZUhvc3QiLCJob3N0IiwiQXJyYXkiLCJ0cmltQ29udHJvbENoYXJzIiwicmVwbGFjZSIsInRyaW1UYWJBbmROZXdsaW5lIiwic2hvcnRlblBhdGgiLCJwYXRoIiwiaXNOb3JtYWxpemVkV2luZG93c0RyaXZlTGV0dGVyIiwiaW5jbHVkZXNDcmVkZW50aWFscyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJjYW5ub3RIYXZlQVVzZXJuYW1lUGFzc3dvcmRQb3J0IiwiY2Fubm90QmVBQmFzZVVSTCIsIlVSTFN0YXRlTWFjaGluZSIsImJhc2UiLCJlbmNvZGluZ092ZXJyaWRlIiwic3RhdGVPdmVycmlkZSIsInBhcnNlRXJyb3IiLCJwb3J0IiwicXVlcnkiLCJmcmFnbWVudCIsInJlcyIsInN0YXRlIiwiYXRGbGFnIiwiYXJyRmxhZyIsInBhc3N3b3JkVG9rZW5TZWVuRmxhZyIsInJldCIsInByb3RvdHlwZSIsInBhcnNlU2NoZW1lU3RhcnQiLCJwYXJzZVNjaGVtZSIsInBhcnNlTm9TY2hlbWUiLCJwYXJzZVNwZWNpYWxSZWxhdGl2ZU9yQXV0aG9yaXR5IiwicGFyc2VQYXRoT3JBdXRob3JpdHkiLCJwYXJzZVJlbGF0aXZlIiwicGFyc2VSZWxhdGl2ZVNsYXNoIiwicGFyc2VTcGVjaWFsQXV0aG9yaXR5U2xhc2hlcyIsInBhcnNlU3BlY2lhbEF1dGhvcml0eUlnbm9yZVNsYXNoZXMiLCJwYXJzZUF1dGhvcml0eSIsImNvZGVQb2ludCIsImVuY29kZWRDb2RlUG9pbnRzIiwicGFyc2VIb3N0TmFtZSIsInBhcnNlUG9ydCIsImZpbGVPdGhlcndpc2VDb2RlUG9pbnRzIiwicGFyc2VGaWxlIiwicGFyc2VGaWxlU2xhc2giLCJwYXJzZUZpbGVIb3N0IiwicGFyc2VQYXRoU3RhcnQiLCJwYXJzZVBhdGgiLCJzaGlmdCIsInBhcnNlQ2Fubm90QmVBQmFzZVVSTFBhdGgiLCJwYXJzZVF1ZXJ5IiwicGFyc2VGcmFnbWVudCIsInNlcmlhbGl6ZVVSTCIsImV4Y2x1ZGVGcmFnbWVudCIsInNlcmlhbGl6ZU9yaWdpbiIsInR1cGxlIiwicmVzdWx0IiwibW9kdWxlIiwiZXhwb3J0cyIsInNlcmlhbGl6ZVVSTE9yaWdpbiIsInBhcnNlVVJMIiwiZSIsImJhc2ljVVJMUGFyc2UiLCJvcHRpb25zIiwidXNtIiwiYmFzZVVSTCIsInNldFRoZVVzZXJuYW1lIiwic2V0VGhlUGFzc3dvcmQiLCJzZXJpYWxpemVJbnRlZ2VyIiwiaW50ZWdlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\nmodule.exports.mixin = function mixin(target, source) {\n    const keys = Object.getOwnPropertyNames(source);\n    for(let i = 0; i < keys.length; ++i){\n        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n    }\n};\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\nmodule.exports.wrapperForImpl = function(impl) {\n    return impl[module.exports.wrapperSymbol];\n};\nmodule.exports.implForWrapper = function(wrapper) {\n    return wrapper[module.exports.implSymbol];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsb0JBQW9CLEdBQUcsU0FBU0UsTUFBTUMsTUFBTSxFQUFFQyxNQUFNO0lBQ2xELE1BQU1DLE9BQU9DLE9BQU9DLG1CQUFtQixDQUFDSDtJQUN4QyxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUgsS0FBS0ksTUFBTSxFQUFFLEVBQUVELEVBQUc7UUFDcENGLE9BQU9JLGNBQWMsQ0FBQ1AsUUFBUUUsSUFBSSxDQUFDRyxFQUFFLEVBQUVGLE9BQU9LLHdCQUF3QixDQUFDUCxRQUFRQyxJQUFJLENBQUNHLEVBQUU7SUFDeEY7QUFDRjtBQUVBUiw0QkFBNEIsR0FBR2EsT0FBTztBQUN0Q2IseUJBQXlCLEdBQUdhLE9BQU87QUFFbkNiLDZCQUE2QixHQUFHLFNBQVVnQixJQUFJO0lBQzVDLE9BQU9BLElBQUksQ0FBQ2hCLE9BQU9DLE9BQU8sQ0FBQ1csYUFBYSxDQUFDO0FBQzNDO0FBRUFaLDZCQUE2QixHQUFHLFNBQVVrQixPQUFPO0lBQy9DLE9BQU9BLE9BQU8sQ0FBQ2xCLE9BQU9DLE9BQU8sQ0FBQ2EsVUFBVSxDQUFDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9ub2RlX21vZHVsZXMvd2hhdHdnLXVybC9saWIvdXRpbHMuanM/ZTUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5c1tpXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleXNbaV0pKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMud3JhcHBlclN5bWJvbCA9IFN5bWJvbChcIndyYXBwZXJcIik7XG5tb2R1bGUuZXhwb3J0cy5pbXBsU3ltYm9sID0gU3ltYm9sKFwiaW1wbFwiKTtcblxubW9kdWxlLmV4cG9ydHMud3JhcHBlckZvckltcGwgPSBmdW5jdGlvbiAoaW1wbCkge1xuICByZXR1cm4gaW1wbFttb2R1bGUuZXhwb3J0cy53cmFwcGVyU3ltYm9sXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmltcGxGb3JXcmFwcGVyID0gZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgcmV0dXJuIHdyYXBwZXJbbW9kdWxlLmV4cG9ydHMuaW1wbFN5bWJvbF07XG59O1xuXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm1peGluIiwidGFyZ2V0Iiwic291cmNlIiwia2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJpIiwibGVuZ3RoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ3cmFwcGVyU3ltYm9sIiwiU3ltYm9sIiwiaW1wbFN5bWJvbCIsIndyYXBwZXJGb3JJbXBsIiwiaW1wbCIsImltcGxGb3JXcmFwcGVyIiwid3JhcHBlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/node-fetch/lib/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   FetchError: () => (/* binding */ FetchError),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var whatwg_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! whatwg-url */ \"(ssr)/./node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zlib */ \"zlib\");\n\n\n\n\n\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n// fix for \"Readable\" isn't a named export issue\nconst Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;\nconst BUFFER = Symbol(\"buffer\");\nconst TYPE = Symbol(\"type\");\nclass Blob {\n    constructor(){\n        this[TYPE] = \"\";\n        const blobParts = arguments[0];\n        const options = arguments[1];\n        const buffers = [];\n        let size = 0;\n        if (blobParts) {\n            const a = blobParts;\n            const length = Number(a.length);\n            for(let i = 0; i < length; i++){\n                const element = a[i];\n                let buffer;\n                if (element instanceof Buffer) {\n                    buffer = element;\n                } else if (ArrayBuffer.isView(element)) {\n                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n                } else if (element instanceof ArrayBuffer) {\n                    buffer = Buffer.from(element);\n                } else if (element instanceof Blob) {\n                    buffer = element[BUFFER];\n                } else {\n                    buffer = Buffer.from(typeof element === \"string\" ? element : String(element));\n                }\n                size += buffer.length;\n                buffers.push(buffer);\n            }\n        }\n        this[BUFFER] = Buffer.concat(buffers);\n        let type = options && options.type !== undefined && String(options.type).toLowerCase();\n        if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n            this[TYPE] = type;\n        }\n    }\n    get size() {\n        return this[BUFFER].length;\n    }\n    get type() {\n        return this[TYPE];\n    }\n    text() {\n        return Promise.resolve(this[BUFFER].toString());\n    }\n    arrayBuffer() {\n        const buf = this[BUFFER];\n        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        return Promise.resolve(ab);\n    }\n    stream() {\n        const readable = new Readable();\n        readable._read = function() {};\n        readable.push(this[BUFFER]);\n        readable.push(null);\n        return readable;\n    }\n    toString() {\n        return \"[object Blob]\";\n    }\n    slice() {\n        const size = this.size;\n        const start = arguments[0];\n        const end = arguments[1];\n        let relativeStart, relativeEnd;\n        if (start === undefined) {\n            relativeStart = 0;\n        } else if (start < 0) {\n            relativeStart = Math.max(size + start, 0);\n        } else {\n            relativeStart = Math.min(start, size);\n        }\n        if (end === undefined) {\n            relativeEnd = size;\n        } else if (end < 0) {\n            relativeEnd = Math.max(size + end, 0);\n        } else {\n            relativeEnd = Math.min(end, size);\n        }\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const buffer = this[BUFFER];\n        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n        const blob = new Blob([], {\n            type: arguments[2]\n        });\n        blob[BUFFER] = slicedBuffer;\n        return blob;\n    }\n}\nObject.defineProperties(Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n    value: \"Blob\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */ /**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */ function FetchError(message, type, systemError) {\n    Error.call(this, message);\n    this.message = message;\n    this.type = type;\n    // when err.type is `system`, err.code contains system error code\n    if (systemError) {\n        this.code = this.errno = systemError.code;\n    }\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = \"FetchError\";\nlet convert;\ntry {\n    convert = require(\"encoding\").convert;\n} catch (e) {}\nconst INTERNALS = Symbol(\"Body internals\");\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ function Body(body) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;\n    let size = _ref$size === undefined ? 0 : _ref$size;\n    var _ref$timeout = _ref.timeout;\n    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n    if (body == null) {\n        // body is undefined or null\n        body = null;\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        body = Buffer.from(body.toString());\n    } else if (isBlob(body)) ;\n    else if (Buffer.isBuffer(body)) ;\n    else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is ArrayBuffer\n        body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n        // body is ArrayBufferView\n        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ;\n    else {\n        // none of the above\n        // coerce to string then buffer\n        body = Buffer.from(String(body));\n    }\n    this[INTERNALS] = {\n        body,\n        disturbed: false,\n        error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n    if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\n        body.on(\"error\", function(err) {\n            const error = err.name === \"AbortError\" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, \"system\", err);\n            _this[INTERNALS].error = error;\n        });\n    }\n}\nBody.prototype = {\n    get body () {\n        return this[INTERNALS].body;\n    },\n    get bodyUsed () {\n        return this[INTERNALS].disturbed;\n    },\n    /**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */ arrayBuffer () {\n        return consumeBody.call(this).then(function(buf) {\n            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        });\n    },\n    /**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */ blob () {\n        let ct = this.headers && this.headers.get(\"content-type\") || \"\";\n        return consumeBody.call(this).then(function(buf) {\n            return Object.assign(// Prevent copying\n            new Blob([], {\n                type: ct.toLowerCase()\n            }), {\n                [BUFFER]: buf\n            });\n        });\n    },\n    /**\n  * Decode response as json\n  *\n  * @return  Promise\n  */ json () {\n        var _this2 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            try {\n                return JSON.parse(buffer.toString());\n            } catch (err) {\n                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, \"invalid-json\"));\n            }\n        });\n    },\n    /**\n  * Decode response as text\n  *\n  * @return  Promise\n  */ text () {\n        return consumeBody.call(this).then(function(buffer) {\n            return buffer.toString();\n        });\n    },\n    /**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */ buffer () {\n        return consumeBody.call(this);\n    },\n    /**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */ textConverted () {\n        var _this3 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            return convertBody(buffer, _this3.headers);\n        });\n    }\n};\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    }\n});\nBody.mixIn = function(proto) {\n    for (const name of Object.getOwnPropertyNames(Body.prototype)){\n        // istanbul ignore else: future proof\n        if (!(name in proto)) {\n            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n            Object.defineProperty(proto, name, desc);\n        }\n    }\n};\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */ function consumeBody() {\n    var _this4 = this;\n    if (this[INTERNALS].disturbed) {\n        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) {\n        return Body.Promise.reject(this[INTERNALS].error);\n    }\n    let body = this.body;\n    // body is null\n    if (body === null) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is blob\n    if (isBlob(body)) {\n        body = body.stream();\n    }\n    // body is buffer\n    if (Buffer.isBuffer(body)) {\n        return Body.Promise.resolve(body);\n    }\n    // istanbul ignore if: should never happen\n    if (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is stream\n    // get ready to actually consume the body\n    let accum = [];\n    let accumBytes = 0;\n    let abort = false;\n    return new Body.Promise(function(resolve, reject) {\n        let resTimeout;\n        // allow timeout on slow response body\n        if (_this4.timeout) {\n            resTimeout = setTimeout(function() {\n                abort = true;\n                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, \"body-timeout\"));\n            }, _this4.timeout);\n        }\n        // handle stream errors\n        body.on(\"error\", function(err) {\n            if (err.name === \"AbortError\") {\n                // if the request was aborted, reject with this Error\n                abort = true;\n                reject(err);\n            } else {\n                // other errors, such as incorrect content-encoding\n                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n        body.on(\"data\", function(chunk) {\n            if (abort || chunk === null) {\n                return;\n            }\n            if (_this4.size && accumBytes + chunk.length > _this4.size) {\n                abort = true;\n                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, \"max-size\"));\n                return;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        });\n        body.on(\"end\", function() {\n            if (abort) {\n                return;\n            }\n            clearTimeout(resTimeout);\n            try {\n                resolve(Buffer.concat(accum, accumBytes));\n            } catch (err) {\n                // handle streams that have accumulated too much data (issue #414)\n                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n    });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */ function convertBody(buffer, headers) {\n    if (typeof convert !== \"function\") {\n        throw new Error(\"The package `encoding` must be installed to use the textConverted() function\");\n    }\n    const ct = headers.get(\"content-type\");\n    let charset = \"utf-8\";\n    let res, str;\n    // header\n    if (ct) {\n        res = /charset=([^;]*)/i.exec(ct);\n    }\n    // no charset in content type, peek at response body for at most 1024 bytes\n    str = buffer.slice(0, 1024).toString();\n    // html5\n    if (!res && str) {\n        res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // html4\n    if (!res && str) {\n        res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n        if (!res) {\n            res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n            if (res) {\n                res.pop(); // drop last quote\n            }\n        }\n        if (res) {\n            res = /charset=(.*)/i.exec(res.pop());\n        }\n    }\n    // xml\n    if (!res && str) {\n        res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // found charset\n    if (res) {\n        charset = res.pop();\n        // prevent decode issues when sites use incorrect encoding\n        // ref: https://hsivonen.fi/encoding-menu/\n        if (charset === \"gb2312\" || charset === \"gbk\") {\n            charset = \"gb18030\";\n        }\n    }\n    // turn raw buffers into a single utf-8 buffer\n    return convert(buffer, \"UTF-8\", charset).toString();\n}\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */ function isURLSearchParams(obj) {\n    // Duck-typing as a necessary condition.\n    if (typeof obj !== \"object\" || typeof obj.append !== \"function\" || typeof obj.delete !== \"function\" || typeof obj.get !== \"function\" || typeof obj.getAll !== \"function\" || typeof obj.has !== \"function\" || typeof obj.set !== \"function\") {\n        return false;\n    }\n    // Brand-checking and more duck-typing as optional condition.\n    return obj.constructor.name === \"URLSearchParams\" || Object.prototype.toString.call(obj) === \"[object URLSearchParams]\" || typeof obj.sort === \"function\";\n}\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */ function isBlob(obj) {\n    return typeof obj === \"object\" && typeof obj.arrayBuffer === \"function\" && typeof obj.type === \"string\" && typeof obj.stream === \"function\" && typeof obj.constructor === \"function\" && typeof obj.constructor.name === \"string\" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */ function clone(instance) {\n    let p1, p2;\n    let body = instance.body;\n    // don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== \"function\") {\n        // tee instance body\n        p1 = new PassThrough();\n        p2 = new PassThrough();\n        body.pipe(p1);\n        body.pipe(p2);\n        // set instance body to teed body and return the other teed body\n        instance[INTERNALS].body = p1;\n        body = p2;\n    }\n    return body;\n}\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */ function extractContentType(body) {\n    if (body === null) {\n        // body is null\n        return null;\n    } else if (typeof body === \"string\") {\n        // body is string\n        return \"text/plain;charset=UTF-8\";\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isBlob(body)) {\n        // body is blob\n        return body.type || null;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return null;\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is ArrayBuffer\n        return null;\n    } else if (ArrayBuffer.isView(body)) {\n        // body is ArrayBufferView\n        return null;\n    } else if (typeof body.getBoundary === \"function\") {\n        // detect form data input from form-data module\n        return `multipart/form-data;boundary=${body.getBoundary()}`;\n    } else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\n        // body is stream\n        // can't really do much about this\n        return null;\n    } else {\n        // Body constructor defaults other things to string\n        return \"text/plain;charset=UTF-8\";\n    }\n}\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */ function getTotalBytes(instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        return 0;\n    } else if (isBlob(body)) {\n        return body.size;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return body.length;\n    } else if (body && typeof body.getLengthSync === \"function\") {\n        // detect form data input from form-data module\n        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) {\n            // 2.x\n            return body.getLengthSync();\n        }\n        return null;\n    } else {\n        // body is stream\n        return null;\n    }\n}\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */ function writeToStream(dest, instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        dest.end();\n    } else if (isBlob(body)) {\n        body.stream().pipe(dest);\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        dest.write(body);\n        dest.end();\n    } else {\n        // body is stream\n        body.pipe(dest);\n    }\n}\n// expose Promise\nBody.Promise = global.Promise;\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */ const invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction validateName(name) {\n    name = `${name}`;\n    if (invalidTokenRegex.test(name) || name === \"\") {\n        throw new TypeError(`${name} is not a legal HTTP header name`);\n    }\n}\nfunction validateValue(value) {\n    value = `${value}`;\n    if (invalidHeaderCharRegex.test(value)) {\n        throw new TypeError(`${value} is not a legal HTTP header value`);\n    }\n}\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */ function find(map, name) {\n    name = name.toLowerCase();\n    for(const key in map){\n        if (key.toLowerCase() === name) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst MAP = Symbol(\"map\");\nclass Headers {\n    /**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */ constructor(){\n        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        this[MAP] = Object.create(null);\n        if (init instanceof Headers) {\n            const rawHeaders = init.raw();\n            const headerNames = Object.keys(rawHeaders);\n            for (const headerName of headerNames){\n                for (const value of rawHeaders[headerName]){\n                    this.append(headerName, value);\n                }\n            }\n            return;\n        }\n        // We don't worry about converting prop to ByteString here as append()\n        // will handle it.\n        if (init == null) ;\n        else if (typeof init === \"object\") {\n            const method = init[Symbol.iterator];\n            if (method != null) {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                const pairs = [];\n                for (const pair of init){\n                    if (typeof pair !== \"object\" || typeof pair[Symbol.iterator] !== \"function\") {\n                        throw new TypeError(\"Each header pair must be iterable\");\n                    }\n                    pairs.push(Array.from(pair));\n                }\n                for (const pair of pairs){\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    this.append(pair[0], pair[1]);\n                }\n            } else {\n                // record<ByteString, ByteString>\n                for (const key of Object.keys(init)){\n                    const value = init[key];\n                    this.append(key, value);\n                }\n            }\n        } else {\n            throw new TypeError(\"Provided initializer must be an object\");\n        }\n    }\n    /**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */ get(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key === undefined) {\n            return null;\n        }\n        return this[MAP][key].join(\", \");\n    }\n    /**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */ forEach(callback) {\n        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        let pairs = getHeaders(this);\n        let i = 0;\n        while(i < pairs.length){\n            var _pairs$i = pairs[i];\n            const name = _pairs$i[0], value = _pairs$i[1];\n            callback.call(thisArg, value, name, this);\n            pairs = getHeaders(this);\n            i++;\n        }\n    }\n    /**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ set(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        this[MAP][key !== undefined ? key : name] = [\n            value\n        ];\n    }\n    /**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ append(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            this[MAP][key].push(value);\n        } else {\n            this[MAP][name] = [\n                value\n            ];\n        }\n    }\n    /**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */ has(name) {\n        name = `${name}`;\n        validateName(name);\n        return find(this[MAP], name) !== undefined;\n    }\n    /**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */ delete(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            delete this[MAP][key];\n        }\n    }\n    /**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */ raw() {\n        return this[MAP];\n    }\n    /**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */ keys() {\n        return createHeadersIterator(this, \"key\");\n    }\n    /**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */ values() {\n        return createHeadersIterator(this, \"value\");\n    }\n    /**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */ [Symbol.iterator]() {\n        return createHeadersIterator(this, \"key+value\");\n    }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n    value: \"Headers\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Headers.prototype, {\n    get: {\n        enumerable: true\n    },\n    forEach: {\n        enumerable: true\n    },\n    set: {\n        enumerable: true\n    },\n    append: {\n        enumerable: true\n    },\n    has: {\n        enumerable: true\n    },\n    delete: {\n        enumerable: true\n    },\n    keys: {\n        enumerable: true\n    },\n    values: {\n        enumerable: true\n    },\n    entries: {\n        enumerable: true\n    }\n});\nfunction getHeaders(headers) {\n    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"key+value\";\n    const keys = Object.keys(headers[MAP]).sort();\n    return keys.map(kind === \"key\" ? function(k) {\n        return k.toLowerCase();\n    } : kind === \"value\" ? function(k) {\n        return headers[MAP][k].join(\", \");\n    } : function(k) {\n        return [\n            k.toLowerCase(),\n            headers[MAP][k].join(\", \")\n        ];\n    });\n}\nconst INTERNAL = Symbol(\"internal\");\nfunction createHeadersIterator(target, kind) {\n    const iterator = Object.create(HeadersIteratorPrototype);\n    iterator[INTERNAL] = {\n        target,\n        kind,\n        index: 0\n    };\n    return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n    next () {\n        // istanbul ignore if\n        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n            throw new TypeError(\"Value of `this` is not a HeadersIterator\");\n        }\n        var _INTERNAL = this[INTERNAL];\n        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;\n        const values = getHeaders(target, kind);\n        const len = values.length;\n        if (index >= len) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        this[INTERNAL].index = index + 1;\n        return {\n            value: values[index],\n            done: false\n        };\n    }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n    value: \"HeadersIterator\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */ function exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign({\n        __proto__: null\n    }, headers[MAP]);\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], \"Host\");\n    if (hostHeaderKey !== undefined) {\n        obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    }\n    return obj;\n}\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */ function createHeadersLenient(obj) {\n    const headers = new Headers();\n    for (const name of Object.keys(obj)){\n        if (invalidTokenRegex.test(name)) {\n            continue;\n        }\n        if (Array.isArray(obj[name])) {\n            for (const val of obj[name]){\n                if (invalidHeaderCharRegex.test(val)) {\n                    continue;\n                }\n                if (headers[MAP][name] === undefined) {\n                    headers[MAP][name] = [\n                        val\n                    ];\n                } else {\n                    headers[MAP][name].push(val);\n                }\n            }\n        } else if (!invalidHeaderCharRegex.test(obj[name])) {\n            headers[MAP][name] = [\n                obj[name]\n            ];\n        }\n    }\n    return headers;\n}\nconst INTERNALS$1 = Symbol(\"Response internals\");\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response {\n    constructor(){\n        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Body.call(this, body, opts);\n        const status = opts.status || 200;\n        const headers = new Headers(opts.headers);\n        if (body != null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(body);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$1] = {\n            url: opts.url,\n            status,\n            statusText: opts.statusText || STATUS_CODES[status],\n            headers,\n            counter: opts.counter\n        };\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n  * Convenience property representing if the request ended normally\n  */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    /**\n  * Clone this response\n  *\n  * @return  Response\n  */ clone() {\n        return new Response(clone(this), {\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected\n        });\n    }\n}\nBody.mixIn(Response.prototype);\nObject.defineProperties(Response.prototype, {\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    redirected: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n    value: \"Response\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nconst INTERNALS$2 = Symbol(\"Request internals\");\nconst URL = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;\nconst format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */ function parseURL(urlStr) {\n    /*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */ if (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n        urlStr = new URL(urlStr).toString();\n    }\n    // Fallback to old implementation for arbitrary URLs\n    return parse_url(urlStr);\n}\nconst streamDestructionSupported = \"destroy\" in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */ function isRequest(input) {\n    return typeof input === \"object\" && typeof input[INTERNALS$2] === \"object\";\n}\nfunction isAbortSignal(signal) {\n    const proto = signal && typeof signal === \"object\" && Object.getPrototypeOf(signal);\n    return !!(proto && proto.constructor.name === \"AbortSignal\");\n}\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request {\n    constructor(input){\n        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let parsedURL;\n        // normalize input\n        if (!isRequest(input)) {\n            if (input && input.href) {\n                // in order to support Node.js' Url objects; though WHATWG's URL objects\n                // will fall into this branch also (since their `toString()` will return\n                // `href` property anyway)\n                parsedURL = parseURL(input.href);\n            } else {\n                // coerce input to a string before attempting to parse\n                parsedURL = parseURL(`${input}`);\n            }\n            input = {};\n        } else {\n            parsedURL = parseURL(input.url);\n        }\n        let method = init.method || input.method || \"GET\";\n        method = method.toUpperCase();\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        Body.call(this, inputBody, {\n            timeout: init.timeout || input.timeout || 0,\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody != null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(inputBody);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) signal = init.signal;\n        if (signal != null && !isAbortSignal(signal)) {\n            throw new TypeError(\"Expected signal to be an instanceof AbortSignal\");\n        }\n        this[INTERNALS$2] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL,\n            signal\n        };\n        // node-fetch-only options\n        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n    }\n    get method() {\n        return this[INTERNALS$2].method;\n    }\n    get url() {\n        return format_url(this[INTERNALS$2].parsedURL);\n    }\n    get headers() {\n        return this[INTERNALS$2].headers;\n    }\n    get redirect() {\n        return this[INTERNALS$2].redirect;\n    }\n    get signal() {\n        return this[INTERNALS$2].signal;\n    }\n    /**\n  * Clone this request\n  *\n  * @return  Request\n  */ clone() {\n        return new Request(this);\n    }\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n    value: \"Request\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    },\n    signal: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */ function getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS$2].parsedURL;\n    const headers = new Headers(request[INTERNALS$2].headers);\n    // fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname) {\n        throw new TypeError(\"Only absolute URLs are supported\");\n    }\n    if (!/^https?:$/.test(parsedURL.protocol)) {\n        throw new TypeError(\"Only HTTP(S) protocols are supported\");\n    }\n    if (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {\n        throw new Error(\"Cancellation of streamed requests with AbortSignal is not supported in node < 8\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body != null) {\n        const totalBytes = getTotalBytes(request);\n        if (typeof totalBytes === \"number\") {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch/1.0 (+https://github.com/bitinn/node-fetch)\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip,deflate\");\n    }\n    let agent = request.agent;\n    if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    return Object.assign({}, parsedURL, {\n        method: request.method,\n        headers: exportNodeCompatibleHeaders(headers),\n        agent\n    });\n}\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */ /**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */ function AbortError(message) {\n    Error.call(this, message);\n    this.type = \"aborted\";\n    this.message = message;\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = \"AbortError\";\nconst URL$1 = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n    const orig = new URL$1(original).hostname;\n    const dest = new URL$1(destination).hostname;\n    return orig === dest || orig[orig.length - dest.length - 1] === \".\" && orig.endsWith(dest);\n};\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isSameProtocol = function isSameProtocol(destination, original) {\n    const orig = new URL$1(original).protocol;\n    const dest = new URL$1(destination).protocol;\n    return orig === dest;\n};\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */ function fetch(url, opts) {\n    // allow custom promise\n    if (!fetch.Promise) {\n        throw new Error(\"native promise missing, set fetch.Promise to your favorite alternative\");\n    }\n    Body.Promise = fetch.Promise;\n    // wrap http.request into fetch\n    return new fetch.Promise(function(resolve, reject) {\n        // build request object\n        const request = new Request(url, opts);\n        const options = getNodeRequestOptions(request);\n        const send = (options.protocol === \"https:\" ? https__WEBPACK_IMPORTED_MODULE_4__ : http__WEBPACK_IMPORTED_MODULE_1__).request;\n        const signal = request.signal;\n        let response = null;\n        const abort = function abort() {\n            let error = new AbortError(\"The user aborted a request.\");\n            reject(error);\n            if (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {\n                destroyStream(request.body, error);\n            }\n            if (!response || !response.body) return;\n            response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n            abort();\n            return;\n        }\n        const abortAndFinalize = function abortAndFinalize() {\n            abort();\n            finalize();\n        };\n        // send request\n        const req = send(options);\n        let reqTimeout;\n        if (signal) {\n            signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        function finalize() {\n            req.abort();\n            if (signal) signal.removeEventListener(\"abort\", abortAndFinalize);\n            clearTimeout(reqTimeout);\n        }\n        if (request.timeout) {\n            req.once(\"socket\", function(socket) {\n                reqTimeout = setTimeout(function() {\n                    reject(new FetchError(`network timeout at: ${request.url}`, \"request-timeout\"));\n                    finalize();\n                }, request.timeout);\n            });\n        }\n        req.on(\"error\", function(err) {\n            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, \"system\", err));\n            if (response && response.body) {\n                destroyStream(response.body, err);\n            }\n            finalize();\n        });\n        fixResponseChunkedTransferBadEnding(req, function(err) {\n            if (signal && signal.aborted) {\n                return;\n            }\n            if (response && response.body) {\n                destroyStream(response.body, err);\n            }\n        });\n        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {\n            // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n            // properly handle when the socket close/end events are out of order.\n            req.on(\"socket\", function(s) {\n                s.addListener(\"close\", function(hadError) {\n                    // if a data listener is still present we didn't end cleanly\n                    const hasDataListener = s.listenerCount(\"data\") > 0;\n                    // if end happened before close but the socket didn't emit an error, do it now\n                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n                        const err = new Error(\"Premature close\");\n                        err.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                        response.body.emit(\"error\", err);\n                    }\n                });\n            });\n        }\n        req.on(\"response\", function(res) {\n            clearTimeout(reqTimeout);\n            const headers = createHeadersLenient(res.headers);\n            // HTTP fetch step 5\n            if (fetch.isRedirect(res.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                let locationURL = null;\n                try {\n                    locationURL = location === null ? null : new URL$1(location, request.url).toString();\n                } catch (err) {\n                    // error here can only be invalid URL in Location: header\n                    // do not throw when options.redirect == manual\n                    // let the user extract the errorneous redirect URL\n                    if (request.redirect !== \"manual\") {\n                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                        finalize();\n                        return;\n                    }\n                }\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n                        if (locationURL !== null) {\n                            // handle corrupted header\n                            try {\n                                headers.set(\"Location\", locationURL);\n                            } catch (err) {\n                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n                                reject(err);\n                            }\n                        }\n                        break;\n                    case \"follow\":\n                        // HTTP-redirect fetch step 2\n                        if (locationURL === null) {\n                            break;\n                        }\n                        // HTTP-redirect fetch step 5\n                        if (request.counter >= request.follow) {\n                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 6 (counter increment)\n                        // Create a new Request object.\n                        const requestOpts = {\n                            headers: new Headers(request.headers),\n                            follow: request.follow,\n                            counter: request.counter + 1,\n                            agent: request.agent,\n                            compress: request.compress,\n                            method: request.method,\n                            body: request.body,\n                            signal: request.signal,\n                            timeout: request.timeout,\n                            size: request.size\n                        };\n                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                            for (const name of [\n                                \"authorization\",\n                                \"www-authenticate\",\n                                \"cookie\",\n                                \"cookie2\"\n                            ]){\n                                requestOpts.headers.delete(name);\n                            }\n                        }\n                        // HTTP-redirect fetch step 9\n                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n                            reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 11\n                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === \"POST\") {\n                            requestOpts.method = \"GET\";\n                            requestOpts.body = undefined;\n                            requestOpts.headers.delete(\"content-length\");\n                        }\n                        // HTTP-redirect fetch step 15\n                        resolve(fetch(new Request(locationURL, requestOpts)));\n                        finalize();\n                        return;\n                }\n            }\n            // prepare response\n            res.once(\"end\", function() {\n                if (signal) signal.removeEventListener(\"abort\", abortAndFinalize);\n            });\n            let body = res.pipe(new PassThrough$1());\n            const response_options = {\n                url: request.url,\n                status: res.statusCode,\n                statusText: res.statusMessage,\n                headers: headers,\n                size: request.size,\n                timeout: request.timeout,\n                counter: request.counter\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH,\n                finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH\n            };\n            // for gzip\n            if (codings == \"gzip\" || codings == \"x-gzip\") {\n                body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createGunzip(zlibOptions));\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // for deflate\n            if (codings == \"deflate\" || codings == \"x-deflate\") {\n                // handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = res.pipe(new PassThrough$1());\n                raw.once(\"data\", function(chunk) {\n                    // see http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflate());\n                    } else {\n                        body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflateRaw());\n                    }\n                    response = new Response(body, response_options);\n                    resolve(response);\n                });\n                raw.on(\"end\", function() {\n                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n                    if (!response) {\n                        response = new Response(body, response_options);\n                        resolve(response);\n                    }\n                });\n                return;\n            }\n            // for br\n            if (codings == \"br\" && typeof zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress === \"function\") {\n                body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress());\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // otherwise, use response as-is\n            response = new Response(body, response_options);\n            resolve(response);\n        });\n        writeToStream(req, request);\n    });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n    let socket;\n    request.on(\"socket\", function(s) {\n        socket = s;\n    });\n    request.on(\"response\", function(response) {\n        const headers = response.headers;\n        if (headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"]) {\n            response.once(\"close\", function(hadError) {\n                // tests for socket presence, as in some situations the\n                // the 'socket' event is not triggered for the request\n                // (happens in deno), avoids `TypeError`\n                // if a data listener is still present we didn't end cleanly\n                const hasDataListener = socket && socket.listenerCount(\"data\") > 0;\n                if (hasDataListener && !hadError) {\n                    const err = new Error(\"Premature close\");\n                    err.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                    errorCallback(err);\n                }\n            });\n        }\n    });\n}\nfunction destroyStream(stream, err) {\n    if (stream.destroy) {\n        stream.destroy(err);\n    } else {\n        // node < 8\n        stream.emit(\"error\", err);\n        stream.end();\n    }\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */ fetch.isRedirect = function(code) {\n    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n// expose Promise\nfetch.Promise = global.Promise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetch);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNKO0FBQ0Y7QUFDYTtBQUNUO0FBQ0Y7QUFFeEIsa0hBQWtIO0FBRWxILGdEQUFnRDtBQUNoRCxNQUFNTSxXQUFXTiw0Q0FBZTtBQUVoQyxNQUFNTyxTQUFTQyxPQUFPO0FBQ3RCLE1BQU1DLE9BQU9ELE9BQU87QUFFcEIsTUFBTUU7SUFDTEMsYUFBYztRQUNiLElBQUksQ0FBQ0YsS0FBSyxHQUFHO1FBRWIsTUFBTUcsWUFBWUMsU0FBUyxDQUFDLEVBQUU7UUFDOUIsTUFBTUMsVUFBVUQsU0FBUyxDQUFDLEVBQUU7UUFFNUIsTUFBTUUsVUFBVSxFQUFFO1FBQ2xCLElBQUlDLE9BQU87UUFFWCxJQUFJSixXQUFXO1lBQ2QsTUFBTUssSUFBSUw7WUFDVixNQUFNTSxTQUFTQyxPQUFPRixFQUFFQyxNQUFNO1lBQzlCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixRQUFRRSxJQUFLO2dCQUNoQyxNQUFNQyxVQUFVSixDQUFDLENBQUNHLEVBQUU7Z0JBQ3BCLElBQUlFO2dCQUNKLElBQUlELG1CQUFtQkUsUUFBUTtvQkFDOUJELFNBQVNEO2dCQUNWLE9BQU8sSUFBSUcsWUFBWUMsTUFBTSxDQUFDSixVQUFVO29CQUN2Q0MsU0FBU0MsT0FBT0csSUFBSSxDQUFDTCxRQUFRQyxNQUFNLEVBQUVELFFBQVFNLFVBQVUsRUFBRU4sUUFBUU8sVUFBVTtnQkFDNUUsT0FBTyxJQUFJUCxtQkFBbUJHLGFBQWE7b0JBQzFDRixTQUFTQyxPQUFPRyxJQUFJLENBQUNMO2dCQUN0QixPQUFPLElBQUlBLG1CQUFtQlgsTUFBTTtvQkFDbkNZLFNBQVNELE9BQU8sQ0FBQ2QsT0FBTztnQkFDekIsT0FBTztvQkFDTmUsU0FBU0MsT0FBT0csSUFBSSxDQUFDLE9BQU9MLFlBQVksV0FBV0EsVUFBVVEsT0FBT1I7Z0JBQ3JFO2dCQUNBTCxRQUFR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QUFrQlQsVUFBVUEsT0FBT1UsYUFBYSxDQUFDLFVBQVU7Z0JBRWpFLElBQUlELG1CQUFtQixDQUFDRCxVQUFVO29CQUNqQyxNQUFNN0ssTUFBTSxJQUFJekIsTUFBTTtvQkFDdEJ5QixJQUFJdkIsSUFBSSxHQUFHO29CQUNYdU4sY0FBY2hNO2dCQUNmO1lBQ0Q7UUFDRDtJQUNEO0FBQ0Q7QUFFQSxTQUFTMkosY0FBYzdNLE1BQU0sRUFBRWtELEdBQUc7SUFDakMsSUFBSWxELE9BQU9tUCxPQUFPLEVBQUU7UUFDbkJuUCxPQUFPbVAsT0FBTyxDQUFDak07SUFDaEIsT0FBTztRQUNOLFdBQVc7UUFDWGxELE9BQU84TSxJQUFJLENBQUMsU0FBUzVKO1FBQ3JCbEQsT0FBT0ksR0FBRztJQUNYO0FBQ0Q7QUFFQTs7Ozs7Q0FLQyxHQUNEc00sTUFBTXdCLFVBQVUsR0FBRyxTQUFVdk0sSUFBSTtJQUNoQyxPQUFPQSxTQUFTLE9BQU9BLFNBQVMsT0FBT0EsU0FBUyxPQUFPQSxTQUFTLE9BQU9BLFNBQVM7QUFDakY7QUFFQSxpQkFBaUI7QUFDakIrSyxNQUFNak4sT0FBTyxHQUFHbUgsT0FBT25ILE9BQU87QUFFOUIsaUVBQWVpTixLQUFLQSxFQUFDO0FBQ3lDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9saWIvaW5kZXgubWpzPzQwYTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgVXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgd2hhdHdnVXJsIGZyb20gJ3doYXR3Zy11cmwnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG1wdmFyL2pzZG9tL2Jsb2IvYWE4NWIyYWJmMDc3NjZmZjdiZjVjMWY2ZGFhZmIzNzI2ZjJmMmRiNS9saWIvanNkb20vbGl2aW5nL2Jsb2IuanNcblxuLy8gZml4IGZvciBcIlJlYWRhYmxlXCIgaXNuJ3QgYSBuYW1lZCBleHBvcnQgaXNzdWVcbmNvbnN0IFJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlO1xuXG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuXG5jbGFzcyBCbG9iIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpc1tUWVBFXSA9ICcnO1xuXG5cdFx0Y29uc3QgYmxvYlBhcnRzID0gYXJndW1lbnRzWzBdO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG5cblx0XHRjb25zdCBidWZmZXJzID0gW107XG5cdFx0bGV0IHNpemUgPSAwO1xuXG5cdFx0aWYgKGJsb2JQYXJ0cykge1xuXHRcdFx0Y29uc3QgYSA9IGJsb2JQYXJ0cztcblx0XHRcdGNvbnN0IGxlbmd0aCA9IE51bWJlcihhLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBhW2ldO1xuXHRcdFx0XHRsZXQgYnVmZmVyO1xuXHRcdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IGVsZW1lbnQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gQnVmZmVyLmZyb20oZWxlbWVudC5idWZmZXIsIGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbShlbGVtZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IGVsZW1lbnRbQlVGRkVSXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbSh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgPyBlbGVtZW50IDogU3RyaW5nKGVsZW1lbnQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzaXplICs9IGJ1ZmZlci5sZW5ndGg7XG5cdFx0XHRcdGJ1ZmZlcnMucHVzaChidWZmZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG5cblx0XHRsZXQgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKG9wdGlvbnMudHlwZSkudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodHlwZSAmJiAhL1teXFx1MDAyMC1cXHUwMDdFXS8udGVzdCh0eXBlKSkge1xuXHRcdFx0dGhpc1tUWVBFXSA9IHR5cGU7XG5cdFx0fVxuXHR9XG5cdGdldCBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzW0JVRkZFUl0ubGVuZ3RoO1xuXHR9XG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiB0aGlzW1RZUEVdO1xuXHR9XG5cdHRleHQoKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzW0JVRkZFUl0udG9TdHJpbmcoKSk7XG5cdH1cblx0YXJyYXlCdWZmZXIoKSB7XG5cdFx0Y29uc3QgYnVmID0gdGhpc1tCVUZGRVJdO1xuXHRcdGNvbnN0IGFiID0gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShhYik7XG5cdH1cblx0c3RyZWFtKCkge1xuXHRcdGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlKCk7XG5cdFx0cmVhZGFibGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRyZWFkYWJsZS5wdXNoKHRoaXNbQlVGRkVSXSk7XG5cdFx0cmVhZGFibGUucHVzaChudWxsKTtcblx0XHRyZXR1cm4gcmVhZGFibGU7XG5cdH1cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuICdbb2JqZWN0IEJsb2JdJztcblx0fVxuXHRzbGljZSgpIHtcblx0XHRjb25zdCBzaXplID0gdGhpcy5zaXplO1xuXG5cdFx0Y29uc3Qgc3RhcnQgPSBhcmd1bWVudHNbMF07XG5cdFx0Y29uc3QgZW5kID0gYXJndW1lbnRzWzFdO1xuXHRcdGxldCByZWxhdGl2ZVN0YXJ0LCByZWxhdGl2ZUVuZDtcblx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVsYXRpdmVTdGFydCA9IDA7XG5cdFx0fSBlbHNlIGlmIChzdGFydCA8IDApIHtcblx0XHRcdHJlbGF0aXZlU3RhcnQgPSBNYXRoLm1heChzaXplICsgc3RhcnQsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWxhdGl2ZVN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIHNpemUpO1xuXHRcdH1cblx0XHRpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbGF0aXZlRW5kID0gc2l6ZTtcblx0XHR9IGVsc2UgaWYgKGVuZCA8IDApIHtcblx0XHRcdHJlbGF0aXZlRW5kID0gTWF0aC5tYXgoc2l6ZSArIGVuZCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbGF0aXZlRW5kID0gTWF0aC5taW4oZW5kLCBzaXplKTtcblx0XHR9XG5cdFx0Y29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMCk7XG5cblx0XHRjb25zdCBidWZmZXIgPSB0aGlzW0JVRkZFUl07XG5cdFx0Y29uc3Qgc2xpY2VkQnVmZmVyID0gYnVmZmVyLnNsaWNlKHJlbGF0aXZlU3RhcnQsIHJlbGF0aXZlU3RhcnQgKyBzcGFuKTtcblx0XHRjb25zdCBibG9iID0gbmV3IEJsb2IoW10sIHsgdHlwZTogYXJndW1lbnRzWzJdIH0pO1xuXHRcdGJsb2JbQlVGRkVSXSA9IHNsaWNlZEJ1ZmZlcjtcblx0XHRyZXR1cm4gYmxvYjtcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbG9iLnByb3RvdHlwZSwge1xuXHRzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0dHlwZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9iLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnQmxvYicsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogZmV0Y2gtZXJyb3IuanNcbiAqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgRmV0Y2hFcnJvciBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIG1lc3NhZ2UgICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuICogQHBhcmFtICAgU3RyaW5nICAgICAgdHlwZSAgICAgICAgIEVycm9yIHR5cGUgZm9yIG1hY2hpbmVcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIHN5c3RlbUVycm9yICBGb3IgTm9kZS5qcyBzeXN0ZW0gZXJyb3JcbiAqIEByZXR1cm4gIEZldGNoRXJyb3JcbiAqL1xuZnVuY3Rpb24gRmV0Y2hFcnJvcihtZXNzYWdlLCB0eXBlLCBzeXN0ZW1FcnJvcikge1xuICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgLy8gd2hlbiBlcnIudHlwZSBpcyBgc3lzdGVtYCwgZXJyLmNvZGUgY29udGFpbnMgc3lzdGVtIGVycm9yIGNvZGVcbiAgaWYgKHN5c3RlbUVycm9yKSB7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG4gIH1cblxuICAvLyBoaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xufVxuXG5GZXRjaEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkZldGNoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmV0Y2hFcnJvcjtcbkZldGNoRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRmV0Y2hFcnJvcic7XG5cbmxldCBjb252ZXJ0O1xudHJ5IHtcblx0Y29udmVydCA9IHJlcXVpcmUoJ2VuY29kaW5nJykuY29udmVydDtcbn0gY2F0Y2ggKGUpIHt9XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnQm9keSBpbnRlcm5hbHMnKTtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiUGFzc1Rocm91Z2hcIiBpc24ndCBhIG5hbWVkIGV4cG9ydCBmb3Igbm9kZSA8MTBcbmNvbnN0IFBhc3NUaHJvdWdoID0gU3RyZWFtLlBhc3NUaHJvdWdoO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5mdW5jdGlvbiBCb2R5KGJvZHkpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblxuXHR2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG5cdCAgICBfcmVmJHNpemUgPSBfcmVmLnNpemU7XG5cblx0bGV0IHNpemUgPSBfcmVmJHNpemUgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHNpemU7XG5cdHZhciBfcmVmJHRpbWVvdXQgPSBfcmVmLnRpbWVvdXQ7XG5cdGxldCB0aW1lb3V0ID0gX3JlZiR0aW1lb3V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0aW1lb3V0O1xuXG5cdGlmIChib2R5ID09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0Ym9keSA9IG51bGw7XG5cdH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkudG9TdHJpbmcoKSk7XG5cdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSA7IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkgOyBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkpO1xuXHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCk7XG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgOyBlbHNlIHtcblx0XHQvLyBub25lIG9mIHRoZSBhYm92ZVxuXHRcdC8vIGNvZXJjZSB0byBzdHJpbmcgdGhlbiBidWZmZXJcblx0XHRib2R5ID0gQnVmZmVyLmZyb20oU3RyaW5nKGJvZHkpKTtcblx0fVxuXHR0aGlzW0lOVEVSTkFMU10gPSB7XG5cdFx0Ym9keSxcblx0XHRkaXN0dXJiZWQ6IGZhbHNlLFxuXHRcdGVycm9yOiBudWxsXG5cdH07XG5cdHRoaXMuc2l6ZSA9IHNpemU7XG5cdHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG5cblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHRib2R5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGNvbnN0IGVycm9yID0gZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJyA/IGVyciA6IG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7X3RoaXMudXJsfTogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKTtcblx0XHRcdF90aGlzW0lOVEVSTkFMU10uZXJyb3IgPSBlcnJvcjtcblx0XHR9KTtcblx0fVxufVxuXG5Cb2R5LnByb3RvdHlwZSA9IHtcblx0Z2V0IGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5ib2R5O1xuXHR9LFxuXG5cdGdldCBib2R5VXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZDtcblx0fSxcblxuXHQvKipcbiAgKiBEZWNvZGUgcmVzcG9uc2UgYXMgQXJyYXlCdWZmZXJcbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0YXJyYXlCdWZmZXIoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmKSB7XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogUmV0dXJuIHJhdyByZXNwb25zZSBhcyBCbG9iXG4gICpcbiAgKiBAcmV0dXJuIFByb21pc2VcbiAgKi9cblx0YmxvYigpIHtcblx0XHRsZXQgY3QgPSB0aGlzLmhlYWRlcnMgJiYgdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihcblx0XHRcdC8vIFByZXZlbnQgY29weWluZ1xuXHRcdFx0bmV3IEJsb2IoW10sIHtcblx0XHRcdFx0dHlwZTogY3QudG9Mb3dlckNhc2UoKVxuXHRcdFx0fSksIHtcblx0XHRcdFx0W0JVRkZFUl06IGJ1ZlxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIGpzb25cbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0anNvbigpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KG5ldyBGZXRjaEVycm9yKGBpbnZhbGlkIGpzb24gcmVzcG9uc2UgYm9keSBhdCAke190aGlzMi51cmx9IHJlYXNvbjogJHtlcnIubWVzc2FnZX1gLCAnaW52YWxpZC1qc29uJykpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyB0ZXh0XG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdHRleHQoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIGJ1ZmZlciAobm9uLXNwZWMgYXBpKVxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHRidWZmZXIoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcyk7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHQsIHdoaWxlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBlbmNvZGluZyBhbmRcbiAgKiB0cnlpbmcgdG8gZGVjb2RlIHRvIFVURi04IChub24tc3BlYyBhcGkpXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdHRleHRDb252ZXJ0ZWQoKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRyZXR1cm4gY29uc3VtZUJvZHkuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHJldHVybiBjb252ZXJ0Qm9keShidWZmZXIsIF90aGlzMy5oZWFkZXJzKTtcblx0XHR9KTtcblx0fVxufTtcblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGJvZHlVc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YXJyYXlCdWZmZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRibG9iOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0anNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHRleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuQm9keS5taXhJbiA9IGZ1bmN0aW9uIChwcm90bykge1xuXHRmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQm9keS5wcm90b3R5cGUpKSB7XG5cdFx0Ly8gaXN0YW5idWwgaWdub3JlIGVsc2U6IGZ1dHVyZSBwcm9vZlxuXHRcdGlmICghKG5hbWUgaW4gcHJvdG8pKSB7XG5cdFx0XHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihCb2R5LnByb3RvdHlwZSwgbmFtZSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIGRlc2MpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDb25zdW1lIGFuZCBjb252ZXJ0IGFuIGVudGlyZSBCb2R5IHRvIGEgQnVmZmVyLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqXG4gKiBAcmV0dXJuICBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVCb2R5KCkge1xuXHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRpZiAodGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZCkge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHt0aGlzLnVybH1gKSk7XG5cdH1cblxuXHR0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkID0gdHJ1ZTtcblxuXHRpZiAodGhpc1tJTlRFUk5BTFNdLmVycm9yKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZWplY3QodGhpc1tJTlRFUk5BTFNdLmVycm9yKTtcblx0fVxuXG5cdGxldCBib2R5ID0gdGhpcy5ib2R5O1xuXG5cdC8vIGJvZHkgaXMgbnVsbFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVzb2x2ZShCdWZmZXIuYWxsb2MoMCkpO1xuXHR9XG5cblx0Ly8gYm9keSBpcyBibG9iXG5cdGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRib2R5ID0gYm9keS5zdHJlYW0oKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgYnVmZmVyXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoYm9keSk7XG5cdH1cblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWY6IHNob3VsZCBuZXZlciBoYXBwZW5cblx0aWYgKCEoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoQnVmZmVyLmFsbG9jKDApKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgc3RyZWFtXG5cdC8vIGdldCByZWFkeSB0byBhY3R1YWxseSBjb25zdW1lIHRoZSBib2R5XG5cdGxldCBhY2N1bSA9IFtdO1xuXHRsZXQgYWNjdW1CeXRlcyA9IDA7XG5cdGxldCBhYm9ydCA9IGZhbHNlO1xuXG5cdHJldHVybiBuZXcgQm9keS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRsZXQgcmVzVGltZW91dDtcblxuXHRcdC8vIGFsbG93IHRpbWVvdXQgb24gc2xvdyByZXNwb25zZSBib2R5XG5cdFx0aWYgKF90aGlzNC50aW1lb3V0KSB7XG5cdFx0XHRyZXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBSZXNwb25zZSB0aW1lb3V0IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke190aGlzNC51cmx9IChvdmVyICR7X3RoaXM0LnRpbWVvdXR9bXMpYCwgJ2JvZHktdGltZW91dCcpKTtcblx0XHRcdH0sIF90aGlzNC50aW1lb3V0KTtcblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgc3RyZWFtIGVycm9yc1xuXHRcdGJvZHkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0aWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcblx0XHRcdFx0Ly8gaWYgdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQsIHJlamVjdCB3aXRoIHRoaXMgRXJyb3Jcblx0XHRcdFx0YWJvcnQgPSB0cnVlO1xuXHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG90aGVyIGVycm9ycywgc3VjaCBhcyBpbmNvcnJlY3QgY29udGVudC1lbmNvZGluZ1xuXHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtfdGhpczQudXJsfTogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRib2R5Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHRpZiAoYWJvcnQgfHwgY2h1bmsgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX3RoaXM0LnNpemUgJiYgYWNjdW1CeXRlcyArIGNodW5rLmxlbmd0aCA+IF90aGlzNC5zaXplKSB7XG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBjb250ZW50IHNpemUgYXQgJHtfdGhpczQudXJsfSBvdmVyIGxpbWl0OiAke190aGlzNC5zaXplfWAsICdtYXgtc2l6ZScpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRhY2N1bUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblx0XHRcdGFjY3VtLnB1c2goY2h1bmspO1xuXHRcdH0pO1xuXG5cdFx0Ym9keS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGFib3J0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2xlYXJUaW1lb3V0KHJlc1RpbWVvdXQpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlKEJ1ZmZlci5jb25jYXQoYWNjdW0sIGFjY3VtQnl0ZXMpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHQvLyBoYW5kbGUgc3RyZWFtcyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdG9vIG11Y2ggZGF0YSAoaXNzdWUgIzQxNClcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIEJ1ZmZlciBmcm9tIHJlc3BvbnNlIGJvZHkgZm9yICR7X3RoaXM0LnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgYnVmZmVyIGVuY29kaW5nIGFuZCBjb252ZXJ0IHRvIHRhcmdldCBlbmNvZGluZ1xuICogcmVmOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3BhcnNpbmcuaHRtbCNkZXRlcm1pbmluZy10aGUtY2hhcmFjdGVyLWVuY29kaW5nXG4gKlxuICogQHBhcmFtICAgQnVmZmVyICBidWZmZXIgICAgSW5jb21pbmcgYnVmZmVyXG4gKiBAcGFyYW0gICBTdHJpbmcgIGVuY29kaW5nICBUYXJnZXQgZW5jb2RpbmdcbiAqIEByZXR1cm4gIFN0cmluZ1xuICovXG5mdW5jdGlvbiBjb252ZXJ0Qm9keShidWZmZXIsIGhlYWRlcnMpIHtcblx0aWYgKHR5cGVvZiBjb252ZXJ0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcGFja2FnZSBgZW5jb2RpbmdgIG11c3QgYmUgaW5zdGFsbGVkIHRvIHVzZSB0aGUgdGV4dENvbnZlcnRlZCgpIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRjb25zdCBjdCA9IGhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcblx0bGV0IGNoYXJzZXQgPSAndXRmLTgnO1xuXHRsZXQgcmVzLCBzdHI7XG5cblx0Ly8gaGVhZGVyXG5cdGlmIChjdCkge1xuXHRcdHJlcyA9IC9jaGFyc2V0PShbXjtdKikvaS5leGVjKGN0KTtcblx0fVxuXG5cdC8vIG5vIGNoYXJzZXQgaW4gY29udGVudCB0eXBlLCBwZWVrIGF0IHJlc3BvbnNlIGJvZHkgZm9yIGF0IG1vc3QgMTAyNCBieXRlc1xuXHRzdHIgPSBidWZmZXIuc2xpY2UoMCwgMTAyNCkudG9TdHJpbmcoKTtcblxuXHQvLyBodG1sNVxuXHRpZiAoIXJlcyAmJiBzdHIpIHtcblx0XHRyZXMgPSAvPG1ldGEuKz9jaGFyc2V0PShbJ1wiXSkoLis/KVxcMS9pLmV4ZWMoc3RyKTtcblx0fVxuXG5cdC8vIGh0bWw0XG5cdGlmICghcmVzICYmIHN0cikge1xuXHRcdHJlcyA9IC88bWV0YVtcXHNdKz9odHRwLWVxdWl2PShbJ1wiXSljb250ZW50LXR5cGVcXDFbXFxzXSs/Y29udGVudD0oWydcIl0pKC4rPylcXDIvaS5leGVjKHN0cik7XG5cdFx0aWYgKCFyZXMpIHtcblx0XHRcdHJlcyA9IC88bWV0YVtcXHNdKz9jb250ZW50PShbJ1wiXSkoLis/KVxcMVtcXHNdKz9odHRwLWVxdWl2PShbJ1wiXSljb250ZW50LXR5cGVcXDMvaS5leGVjKHN0cik7XG5cdFx0XHRpZiAocmVzKSB7XG5cdFx0XHRcdHJlcy5wb3AoKTsgLy8gZHJvcCBsYXN0IHF1b3RlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJlcykge1xuXHRcdFx0cmVzID0gL2NoYXJzZXQ9KC4qKS9pLmV4ZWMocmVzLnBvcCgpKTtcblx0XHR9XG5cdH1cblxuXHQvLyB4bWxcblx0aWYgKCFyZXMgJiYgc3RyKSB7XG5cdFx0cmVzID0gLzxcXD94bWwuKz9lbmNvZGluZz0oWydcIl0pKC4rPylcXDEvaS5leGVjKHN0cik7XG5cdH1cblxuXHQvLyBmb3VuZCBjaGFyc2V0XG5cdGlmIChyZXMpIHtcblx0XHRjaGFyc2V0ID0gcmVzLnBvcCgpO1xuXG5cdFx0Ly8gcHJldmVudCBkZWNvZGUgaXNzdWVzIHdoZW4gc2l0ZXMgdXNlIGluY29ycmVjdCBlbmNvZGluZ1xuXHRcdC8vIHJlZjogaHR0cHM6Ly9oc2l2b25lbi5maS9lbmNvZGluZy1tZW51L1xuXHRcdGlmIChjaGFyc2V0ID09PSAnZ2IyMzEyJyB8fCBjaGFyc2V0ID09PSAnZ2JrJykge1xuXHRcdFx0Y2hhcnNldCA9ICdnYjE4MDMwJztcblx0XHR9XG5cdH1cblxuXHQvLyB0dXJuIHJhdyBidWZmZXJzIGludG8gYSBzaW5nbGUgdXRmLTggYnVmZmVyXG5cdHJldHVybiBjb252ZXJ0KGJ1ZmZlciwgJ1VURi04JywgY2hhcnNldCkudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKiByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRpbm4vbm9kZS1mZXRjaC9pc3N1ZXMvMjk2I2lzc3VlY29tbWVudC0zMDc1OTgxNDNcbiAqXG4gKiBAcGFyYW0gICBPYmplY3QgIG9iaiAgICAgT2JqZWN0IHRvIGRldGVjdCBieSB0eXBlIG9yIGJyYW5kXG4gKiBAcmV0dXJuICBTdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXMob2JqKSB7XG5cdC8vIER1Y2stdHlwaW5nIGFzIGEgbmVjZXNzYXJ5IGNvbmRpdGlvbi5cblx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmouYXBwZW5kICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmouZGVsZXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmouZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmouZ2V0QWxsICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmouaGFzICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmouc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gQnJhbmQtY2hlY2tpbmcgYW5kIG1vcmUgZHVjay10eXBpbmcgYXMgb3B0aW9uYWwgY29uZGl0aW9uLlxuXHRyZXR1cm4gb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVUkxTZWFyY2hQYXJhbXMnIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBVUkxTZWFyY2hQYXJhbXNdJyB8fCB0eXBlb2Ygb2JqLnNvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBXM0MgYEJsb2JgIG9iamVjdCAod2hpY2ggYEZpbGVgIGluaGVyaXRzIGZyb20pXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQmxvYihvYmopIHtcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmouYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai50eXBlID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb2JqLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ3N0cmluZycgJiYgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqLmNvbnN0cnVjdG9yLm5hbWUpICYmIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9ialtTeW1ib2wudG9TdHJpbmdUYWddKTtcbn1cblxuLyoqXG4gKiBDbG9uZSBib2R5IGdpdmVuIFJlcy9SZXEgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgaW5zdGFuY2UgIFJlc3BvbnNlIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4gIE1peGVkXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGluc3RhbmNlKSB7XG5cdGxldCBwMSwgcDI7XG5cdGxldCBib2R5ID0gaW5zdGFuY2UuYm9keTtcblxuXHQvLyBkb24ndCBhbGxvdyBjbG9uaW5nIGEgdXNlZCBib2R5XG5cdGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IGNsb25lIGJvZHkgYWZ0ZXIgaXQgaXMgdXNlZCcpO1xuXHR9XG5cblx0Ly8gY2hlY2sgdGhhdCBib2R5IGlzIGEgc3RyZWFtIGFuZCBub3QgZm9ybS1kYXRhIG9iamVjdFxuXHQvLyBub3RlOiB3ZSBjYW4ndCBjbG9uZSB0aGUgZm9ybS1kYXRhIG9iamVjdCB3aXRob3V0IGhhdmluZyBpdCBhcyBhIGRlcGVuZGVuY3lcblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0gJiYgdHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgIT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyB0ZWUgaW5zdGFuY2UgYm9keVxuXHRcdHAxID0gbmV3IFBhc3NUaHJvdWdoKCk7XG5cdFx0cDIgPSBuZXcgUGFzc1Rocm91Z2goKTtcblx0XHRib2R5LnBpcGUocDEpO1xuXHRcdGJvZHkucGlwZShwMik7XG5cdFx0Ly8gc2V0IGluc3RhbmNlIGJvZHkgdG8gdGVlZCBib2R5IGFuZCByZXR1cm4gdGhlIG90aGVyIHRlZWQgYm9keVxuXHRcdGluc3RhbmNlW0lOVEVSTkFMU10uYm9keSA9IHAxO1xuXHRcdGJvZHkgPSBwMjtcblx0fVxuXG5cdHJldHVybiBib2R5O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIHRoZSBvcGVyYXRpb24gXCJleHRyYWN0IGEgYENvbnRlbnQtVHlwZWAgdmFsdWUgZnJvbSB8b2JqZWN0fFwiIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIHNwZWNpZmljYXRpb246XG4gKiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5aW5pdC1leHRyYWN0XG4gKlxuICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgaW5zdGFuY2UuYm9keSBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSAgIE1peGVkICBpbnN0YW5jZSAgQW55IG9wdGlvbnMuYm9keSBpbnB1dFxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29udGVudFR5cGUoYm9keSkge1xuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIGJvZHkgaXMgbnVsbFxuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdC8vIGJvZHkgaXMgc3RyaW5nXG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRcdHJldHVybiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnO1xuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYmxvYlxuXHRcdHJldHVybiBib2R5LnR5cGUgfHwgbnVsbDtcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuXHRcdC8vIGJvZHkgaXMgQXJyYXlCdWZmZXJcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyVmlld1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gZGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7Ym91bmRhcnk9JHtib2R5LmdldEJvdW5kYXJ5KCl9YDtcblx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHQvLyBjYW4ndCByZWFsbHkgZG8gbXVjaCBhYm91dCB0aGlzXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQm9keSBjb25zdHJ1Y3RvciBkZWZhdWx0cyBvdGhlciB0aGluZ3MgdG8gc3RyaW5nXG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIEZldGNoIFN0YW5kYXJkIHRyZWF0cyB0aGlzIGFzIGlmIFwidG90YWwgYnl0ZXNcIiBpcyBhIHByb3BlcnR5IG9uIHRoZSBib2R5LlxuICogRm9yIHVzLCB3ZSBoYXZlIHRvIGV4cGxpY2l0bHkgZ2V0IGl0IHdpdGggYSBmdW5jdGlvbi5cbiAqXG4gKiByZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktdG90YWwtYnl0ZXNcbiAqXG4gKiBAcGFyYW0gICBCb2R5ICAgIGluc3RhbmNlICAgSW5zdGFuY2Ugb2YgQm9keVxuICogQHJldHVybiAgTnVtYmVyPyAgICAgICAgICAgIE51bWJlciBvZiBieXRlcywgb3IgbnVsbCBpZiBub3QgcG9zc2libGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG90YWxCeXRlcyhpbnN0YW5jZSkge1xuXHRjb25zdCBib2R5ID0gaW5zdGFuY2UuYm9keTtcblxuXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyBudWxsXG5cdFx0cmV0dXJuIDA7XG5cdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkuc2l6ZTtcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRcdHJldHVybiBib2R5Lmxlbmd0aDtcblx0fSBlbHNlIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LmdldExlbmd0aFN5bmMgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBkZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxuXHRcdGlmIChib2R5Ll9sZW5ndGhSZXRyaWV2ZXJzICYmIGJvZHkuX2xlbmd0aFJldHJpZXZlcnMubGVuZ3RoID09IDAgfHwgLy8gMS54XG5cdFx0Ym9keS5oYXNLbm93bkxlbmd0aCAmJiBib2R5Lmhhc0tub3duTGVuZ3RoKCkpIHtcblx0XHRcdC8vIDIueFxuXHRcdFx0cmV0dXJuIGJvZHkuZ2V0TGVuZ3RoU3luYygpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHQvLyBib2R5IGlzIHN0cmVhbVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogV3JpdGUgYSBCb2R5IHRvIGEgTm9kZS5qcyBXcml0YWJsZVN0cmVhbSAoZS5nLiBodHRwLlJlcXVlc3QpIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gICBCb2R5ICAgIGluc3RhbmNlICAgSW5zdGFuY2Ugb2YgQm9keVxuICogQHJldHVybiAgVm9pZFxuICovXG5mdW5jdGlvbiB3cml0ZVRvU3RyZWFtKGRlc3QsIGluc3RhbmNlKSB7XG5cdGNvbnN0IGJvZHkgPSBpbnN0YW5jZS5ib2R5O1xuXG5cblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIG51bGxcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdGJvZHkuc3RyZWFtKCkucGlwZShkZXN0KTtcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRcdGRlc3Qud3JpdGUoYm9keSk7XG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBib2R5IGlzIHN0cmVhbVxuXHRcdGJvZHkucGlwZShkZXN0KTtcblx0fVxufVxuXG4vLyBleHBvc2UgUHJvbWlzZVxuQm9keS5Qcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG5cbi8qKlxuICogaGVhZGVycy5qc1xuICpcbiAqIEhlYWRlcnMgY2xhc3Mgb2ZmZXJzIGNvbnZlbmllbnQgaGVscGVyc1xuICovXG5cbmNvbnN0IGludmFsaWRUb2tlblJlZ2V4ID0gL1teXFxeX2BhLXpBLVpcXC0wLTkhIyQlJicqKy58fl0vO1xuY29uc3QgaW52YWxpZEhlYWRlckNoYXJSZWdleCA9IC9bXlxcdFxceDIwLVxceDdlXFx4ODAtXFx4ZmZdLztcblxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKG5hbWUpIHtcblx0bmFtZSA9IGAke25hbWV9YDtcblx0aWYgKGludmFsaWRUb2tlblJlZ2V4LnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGAke25hbWV9IGlzIG5vdCBhIGxlZ2FsIEhUVFAgaGVhZGVyIG5hbWVgKTtcblx0fVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlKSB7XG5cdHZhbHVlID0gYCR7dmFsdWV9YDtcblx0aWYgKGludmFsaWRIZWFkZXJDaGFyUmVnZXgudGVzdCh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBsZWdhbCBIVFRQIGhlYWRlciB2YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogRmluZCB0aGUga2V5IGluIHRoZSBtYXAgb2JqZWN0IGdpdmVuIGEgaGVhZGVyIG5hbWUuXG4gKlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICpcbiAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgSGVhZGVyIG5hbWVcbiAqIEByZXR1cm4gIFN0cmluZ3xVbmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gZmluZChtYXAsIG5hbWUpIHtcblx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0Zm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG5cdFx0aWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBuYW1lKSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5jb25zdCBNQVAgPSBTeW1ib2woJ21hcCcpO1xuY2xhc3MgSGVhZGVycyB7XG5cdC8qKlxuICAqIEhlYWRlcnMgY2xhc3NcbiAgKlxuICAqIEBwYXJhbSAgIE9iamVjdCAgaGVhZGVycyAgUmVzcG9uc2UgaGVhZGVyc1xuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0bGV0IGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcblxuXHRcdHRoaXNbTUFQXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0XHRpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IHJhd0hlYWRlcnMgPSBpbml0LnJhdygpO1xuXHRcdFx0Y29uc3QgaGVhZGVyTmFtZXMgPSBPYmplY3Qua2V5cyhyYXdIZWFkZXJzKTtcblxuXHRcdFx0Zm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIGhlYWRlck5hbWVzKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgcmF3SGVhZGVyc1toZWFkZXJOYW1lXSkge1xuXHRcdFx0XHRcdHRoaXMuYXBwZW5kKGhlYWRlck5hbWUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3Qgd29ycnkgYWJvdXQgY29udmVydGluZyBwcm9wIHRvIEJ5dGVTdHJpbmcgaGVyZSBhcyBhcHBlbmQoKVxuXHRcdC8vIHdpbGwgaGFuZGxlIGl0LlxuXHRcdGlmIChpbml0ID09IG51bGwpIDsgZWxzZSBpZiAodHlwZW9mIGluaXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zdCBtZXRob2QgPSBpbml0W1N5bWJvbC5pdGVyYXRvcl07XG5cdFx0XHRpZiAobWV0aG9kICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXIgcGFpcnMgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XG5cdFx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdFx0Y29uc3QgcGFpcnMgPSBbXTtcblx0XHRcdFx0Zm9yIChjb25zdCBwYWlyIG9mIGluaXQpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYWlyW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWlycy5wdXNoKEFycmF5LmZyb20ocGFpcikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG5cdFx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYSBuYW1lL3ZhbHVlIHR1cGxlJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuYXBwZW5kKHBhaXJbMF0sIHBhaXJbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyByZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5pdCkpIHtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IGluaXRba2V5XTtcblx0XHRcdFx0XHR0aGlzLmFwcGVuZChrZXksIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBpbml0aWFsaXplciBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIFJldHVybiBjb21iaW5lZCBoZWFkZXIgdmFsdWUgZ2l2ZW4gbmFtZVxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICBIZWFkZXIgbmFtZVxuICAqIEByZXR1cm4gIE1peGVkXG4gICovXG5cdGdldChuYW1lKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xuXHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNbTUFQXVtrZXldLmpvaW4oJywgJyk7XG5cdH1cblxuXHQvKipcbiAgKiBJdGVyYXRlIG92ZXIgYWxsIGhlYWRlcnNcbiAgKlxuICAqIEBwYXJhbSAgIEZ1bmN0aW9uICBjYWxsYmFjayAgRXhlY3V0ZWQgZm9yIGVhY2ggaXRlbSB3aXRoIHBhcmFtZXRlcnMgKHZhbHVlLCBuYW1lLCB0aGlzQXJnKVxuICAqIEBwYXJhbSAgIEJvb2xlYW4gICB0aGlzQXJnICAgYHRoaXNgIGNvbnRleHQgZm9yIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRmb3JFYWNoKGNhbGxiYWNrKSB7XG5cdFx0bGV0IHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuXHRcdGxldCBwYWlycyA9IGdldEhlYWRlcnModGhpcyk7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdHdoaWxlIChpIDwgcGFpcnMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgX3BhaXJzJGkgPSBwYWlyc1tpXTtcblx0XHRcdGNvbnN0IG5hbWUgPSBfcGFpcnMkaVswXSxcblx0XHRcdCAgICAgIHZhbHVlID0gX3BhaXJzJGlbMV07XG5cblx0XHRcdGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuXHRcdFx0cGFpcnMgPSBnZXRIZWFkZXJzKHRoaXMpO1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIE92ZXJ3cml0ZSBoZWFkZXIgdmFsdWVzIGdpdmVuIG5hbWVcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgIEhlYWRlciBuYW1lXG4gICogQHBhcmFtICAgU3RyaW5nICB2YWx1ZSAgSGVhZGVyIHZhbHVlXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRzZXQobmFtZSwgdmFsdWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbHVlID0gYCR7dmFsdWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0dmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xuXHRcdHRoaXNbTUFQXVtrZXkgIT09IHVuZGVmaW5lZCA/IGtleSA6IG5hbWVdID0gW3ZhbHVlXTtcblx0fVxuXG5cdC8qKlxuICAqIEFwcGVuZCBhIHZhbHVlIG9udG8gZXhpc3RpbmcgaGVhZGVyXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgICBIZWFkZXIgbmFtZVxuICAqIEBwYXJhbSAgIFN0cmluZyAgdmFsdWUgIEhlYWRlciB2YWx1ZVxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0YXBwZW5kKG5hbWUsIHZhbHVlKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdHZhbGlkYXRlVmFsdWUodmFsdWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXNbTUFQXVtrZXldLnB1c2godmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW01BUF1bbmFtZV0gPSBbdmFsdWVdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIENoZWNrIGZvciBoZWFkZXIgbmFtZSBleGlzdGVuY2VcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgIG5hbWUgIEhlYWRlciBuYW1lXG4gICogQHJldHVybiAgQm9vbGVhblxuICAqL1xuXHRoYXMobmFtZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdHJldHVybiBmaW5kKHRoaXNbTUFQXSwgbmFtZSkgIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuICAqIERlbGV0ZSBhbGwgaGVhZGVyIHZhbHVlcyBnaXZlbiBuYW1lXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRkZWxldGUobmFtZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRlbGV0ZSB0aGlzW01BUF1ba2V5XTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBSZXR1cm4gcmF3IGhlYWRlcnMgKG5vbi1zcGVjIGFwaSlcbiAgKlxuICAqIEByZXR1cm4gIE9iamVjdFxuICAqL1xuXHRyYXcoKSB7XG5cdFx0cmV0dXJuIHRoaXNbTUFQXTtcblx0fVxuXG5cdC8qKlxuICAqIEdldCBhbiBpdGVyYXRvciBvbiBrZXlzLlxuICAqXG4gICogQHJldHVybiAgSXRlcmF0b3JcbiAgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICdrZXknKTtcblx0fVxuXG5cdC8qKlxuICAqIEdldCBhbiBpdGVyYXRvciBvbiB2YWx1ZXMuXG4gICpcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxuICAqL1xuXHR2YWx1ZXMoKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0aGlzLCAndmFsdWUnKTtcblx0fVxuXG5cdC8qKlxuICAqIEdldCBhbiBpdGVyYXRvciBvbiBlbnRyaWVzLlxuICAqXG4gICogVGhpcyBpcyB0aGUgZGVmYXVsdCBpdGVyYXRvciBvZiB0aGUgSGVhZGVycyBvYmplY3QuXG4gICpcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxuICAqL1xuXHRbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKTtcblx0fVxufVxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkZXJzLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnSGVhZGVycycsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XG5cdGdldDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGZvckVhY2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzZXQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRhcHBlbmQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRoYXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRkZWxldGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRrZXlzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0dmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0ZW50cmllczogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRIZWFkZXJzKGhlYWRlcnMpIHtcblx0bGV0IGtpbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdrZXkrdmFsdWUnO1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzW01BUF0pLnNvcnQoKTtcblx0cmV0dXJuIGtleXMubWFwKGtpbmQgPT09ICdrZXknID8gZnVuY3Rpb24gKGspIHtcblx0XHRyZXR1cm4gay50b0xvd2VyQ2FzZSgpO1xuXHR9IDoga2luZCA9PT0gJ3ZhbHVlJyA/IGZ1bmN0aW9uIChrKSB7XG5cdFx0cmV0dXJuIGhlYWRlcnNbTUFQXVtrXS5qb2luKCcsICcpO1xuXHR9IDogZnVuY3Rpb24gKGspIHtcblx0XHRyZXR1cm4gW2sudG9Mb3dlckNhc2UoKSwgaGVhZGVyc1tNQVBdW2tdLmpvaW4oJywgJyldO1xuXHR9KTtcbn1cblxuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woJ2ludGVybmFsJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0YXJnZXQsIGtpbmQpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSk7XG5cdGl0ZXJhdG9yW0lOVEVSTkFMXSA9IHtcblx0XHR0YXJnZXQsXG5cdFx0a2luZCxcblx0XHRpbmRleDogMFxuXHR9O1xuXHRyZXR1cm4gaXRlcmF0b3I7XG59XG5cbmNvbnN0IEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZih7XG5cdG5leHQoKSB7XG5cdFx0Ly8gaXN0YW5idWwgaWdub3JlIGlmXG5cdFx0aWYgKCF0aGlzIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBvZiBgdGhpc2AgaXMgbm90IGEgSGVhZGVyc0l0ZXJhdG9yJyk7XG5cdFx0fVxuXG5cdFx0dmFyIF9JTlRFUk5BTCA9IHRoaXNbSU5URVJOQUxdO1xuXHRcdGNvbnN0IHRhcmdldCA9IF9JTlRFUk5BTC50YXJnZXQsXG5cdFx0ICAgICAga2luZCA9IF9JTlRFUk5BTC5raW5kLFxuXHRcdCAgICAgIGluZGV4ID0gX0lOVEVSTkFMLmluZGV4O1xuXG5cdFx0Y29uc3QgdmFsdWVzID0gZ2V0SGVhZGVycyh0YXJnZXQsIGtpbmQpO1xuXHRcdGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0aWYgKGluZGV4ID49IGxlbikge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdFx0ZG9uZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMXS5pbmRleCA9IGluZGV4ICsgMTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogdmFsdWVzW2luZGV4XSxcblx0XHRcdGRvbmU6IGZhbHNlXG5cdFx0fTtcblx0fVxufSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ0hlYWRlcnNJdGVyYXRvcicsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogRXhwb3J0IHRoZSBIZWFkZXJzIG9iamVjdCBpbiBhIGZvcm0gdGhhdCBOb2RlLmpzIGNhbiBjb25zdW1lLlxuICpcbiAqIEBwYXJhbSAgIEhlYWRlcnMgIGhlYWRlcnNcbiAqIEByZXR1cm4gIE9iamVjdFxuICovXG5mdW5jdGlvbiBleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMoaGVhZGVycykge1xuXHRjb25zdCBvYmogPSBPYmplY3QuYXNzaWduKHsgX19wcm90b19fOiBudWxsIH0sIGhlYWRlcnNbTUFQXSk7XG5cblx0Ly8gaHR0cC5yZXF1ZXN0KCkgb25seSBzdXBwb3J0cyBzdHJpbmcgYXMgSG9zdCBoZWFkZXIuIFRoaXMgaGFjayBtYWtlc1xuXHQvLyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cblx0Y29uc3QgaG9zdEhlYWRlcktleSA9IGZpbmQoaGVhZGVyc1tNQVBdLCAnSG9zdCcpO1xuXHRpZiAoaG9zdEhlYWRlcktleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2JqW2hvc3RIZWFkZXJLZXldID0gb2JqW2hvc3RIZWFkZXJLZXldWzBdO1xuXHR9XG5cblx0cmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBIZWFkZXJzIG9iamVjdCBmcm9tIGFuIG9iamVjdCBvZiBoZWFkZXJzLCBpZ25vcmluZyB0aG9zZSB0aGF0IGRvXG4gKiBub3QgY29uZm9ybSB0byBIVFRQIGdyYW1tYXIgcHJvZHVjdGlvbnMuXG4gKlxuICogQHBhcmFtICAgT2JqZWN0ICBvYmogIE9iamVjdCBvZiBoZWFkZXJzXG4gKiBAcmV0dXJuICBIZWFkZXJzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNMZW5pZW50KG9iaikge1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcblx0Zm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcblx0XHRpZiAoaW52YWxpZFRva2VuUmVnZXgudGVzdChuYW1lKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KG9ialtuYW1lXSkpIHtcblx0XHRcdGZvciAoY29uc3QgdmFsIG9mIG9ialtuYW1lXSkge1xuXHRcdFx0XHRpZiAoaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KHZhbCkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGVhZGVyc1tNQVBdW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0gPSBbdmFsXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0ucHVzaCh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KG9ialtuYW1lXSkpIHtcblx0XHRcdGhlYWRlcnNbTUFQXVtuYW1lXSA9IFtvYmpbbmFtZV1dO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaGVhZGVycztcbn1cblxuY29uc3QgSU5URVJOQUxTJDEgPSBTeW1ib2woJ1Jlc3BvbnNlIGludGVybmFscycpO1xuXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJTVEFUVVNfQ09ERVNcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBTVEFUVVNfQ09ERVMgPSBodHRwLlNUQVRVU19DT0RFUztcblxuLyoqXG4gKiBSZXNwb25zZSBjbGFzc1xuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVzcG9uc2Uge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRsZXQgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblx0XHRsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblx0XHRCb2R5LmNhbGwodGhpcywgYm9keSwgb3B0cyk7XG5cblx0XHRjb25zdCBzdGF0dXMgPSBvcHRzLnN0YXR1cyB8fCAyMDA7XG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdHMuaGVhZGVycyk7XG5cblx0XHRpZiAoYm9keSAhPSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHkpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFMkMV0gPSB7XG5cdFx0XHR1cmw6IG9wdHMudXJsLFxuXHRcdFx0c3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogb3B0cy5zdGF0dXNUZXh0IHx8IFNUQVRVU19DT0RFU1tzdGF0dXNdLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdGNvdW50ZXI6IG9wdHMuY291bnRlclxuXHRcdH07XG5cdH1cblxuXHRnZXQgdXJsKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS51cmwgfHwgJyc7XG5cdH1cblxuXHRnZXQgc3RhdHVzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXM7XG5cdH1cblxuXHQvKipcbiAgKiBDb252ZW5pZW5jZSBwcm9wZXJ0eSByZXByZXNlbnRpbmcgaWYgdGhlIHJlcXVlc3QgZW5kZWQgbm9ybWFsbHlcbiAgKi9cblx0Z2V0IG9rKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cyA8IDMwMDtcblx0fVxuXG5cdGdldCByZWRpcmVjdGVkKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5jb3VudGVyID4gMDtcblx0fVxuXG5cdGdldCBzdGF0dXNUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXNUZXh0O1xuXHR9XG5cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmhlYWRlcnM7XG5cdH1cblxuXHQvKipcbiAgKiBDbG9uZSB0aGlzIHJlc3BvbnNlXG4gICpcbiAgKiBAcmV0dXJuICBSZXNwb25zZVxuICAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGNsb25lKHRoaXMpLCB7XG5cdFx0XHR1cmw6IHRoaXMudXJsLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdG9rOiB0aGlzLm9rLFxuXHRcdFx0cmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkXG5cdFx0fSk7XG5cdH1cbn1cblxuQm9keS5taXhJbihSZXNwb25zZS5wcm90b3R5cGUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcblx0dXJsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c3RhdHVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0b2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRyZWRpcmVjdGVkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c3RhdHVzVGV4dDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGhlYWRlcnM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRjbG9uZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzcG9uc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdSZXNwb25zZScsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbmNvbnN0IElOVEVSTkFMUyQyID0gU3ltYm9sKCdSZXF1ZXN0IGludGVybmFscycpO1xuY29uc3QgVVJMID0gVXJsLlVSTCB8fCB3aGF0d2dVcmwuVVJMO1xuXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJmb3JtYXRcIiwgXCJwYXJzZVwiIGFyZW4ndCBhIG5hbWVkIGV4cG9ydCBmb3Igbm9kZSA8MTBcbmNvbnN0IHBhcnNlX3VybCA9IFVybC5wYXJzZTtcbmNvbnN0IGZvcm1hdF91cmwgPSBVcmwuZm9ybWF0O1xuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBuZXcgVVJMYCB0byBoYW5kbGUgYXJiaXRyYXJ5IFVSTHNcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybFN0clxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VVUkwodXJsU3RyKSB7XG5cdC8qXG4gXHRDaGVjayB3aGV0aGVyIHRoZSBVUkwgaXMgYWJzb2x1dGUgb3Igbm90XG4gXHRcdFNjaGVtZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcbiBcdEFic29sdXRlIFVSTDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi00LjNcbiAqL1xuXHRpZiAoL15bYS16QS1aXVthLXpBLVpcXGQrXFwtLl0qOi8uZXhlYyh1cmxTdHIpKSB7XG5cdFx0dXJsU3RyID0gbmV3IFVSTCh1cmxTdHIpLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvLyBGYWxsYmFjayB0byBvbGQgaW1wbGVtZW50YXRpb24gZm9yIGFyYml0cmFyeSBVUkxzXG5cdHJldHVybiBwYXJzZV91cmwodXJsU3RyKTtcbn1cblxuY29uc3Qgc3RyZWFtRGVzdHJ1Y3Rpb25TdXBwb3J0ZWQgPSAnZGVzdHJveScgaW4gU3RyZWFtLlJlYWRhYmxlLnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIFJlcXVlc3QuXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgICBpbnB1dFxuICogQHJldHVybiAgQm9vbGVhblxuICovXG5mdW5jdGlvbiBpc1JlcXVlc3QoaW5wdXQpIHtcblx0cmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0W0lOVEVSTkFMUyQyXSA9PT0gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGlzQWJvcnRTaWduYWwoc2lnbmFsKSB7XG5cdGNvbnN0IHByb3RvID0gc2lnbmFsICYmIHR5cGVvZiBzaWduYWwgPT09ICdvYmplY3QnICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihzaWduYWwpO1xuXHRyZXR1cm4gISEocHJvdG8gJiYgcHJvdG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ0Fib3J0U2lnbmFsJyk7XG59XG5cbi8qKlxuICogUmVxdWVzdCBjbGFzc1xuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXQgIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBPYmplY3QgIGluaXQgICBDdXN0b20gb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBSZXF1ZXN0IHtcblx0Y29uc3RydWN0b3IoaW5wdXQpIHtcblx0XHRsZXQgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblx0XHRsZXQgcGFyc2VkVVJMO1xuXG5cdFx0Ly8gbm9ybWFsaXplIGlucHV0XG5cdFx0aWYgKCFpc1JlcXVlc3QoaW5wdXQpKSB7XG5cdFx0XHRpZiAoaW5wdXQgJiYgaW5wdXQuaHJlZikge1xuXHRcdFx0XHQvLyBpbiBvcmRlciB0byBzdXBwb3J0IE5vZGUuanMnIFVybCBvYmplY3RzOyB0aG91Z2ggV0hBVFdHJ3MgVVJMIG9iamVjdHNcblx0XHRcdFx0Ly8gd2lsbCBmYWxsIGludG8gdGhpcyBicmFuY2ggYWxzbyAoc2luY2UgdGhlaXIgYHRvU3RyaW5nKClgIHdpbGwgcmV0dXJuXG5cdFx0XHRcdC8vIGBocmVmYCBwcm9wZXJ0eSBhbnl3YXkpXG5cdFx0XHRcdHBhcnNlZFVSTCA9IHBhcnNlVVJMKGlucHV0LmhyZWYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29lcmNlIGlucHV0IHRvIGEgc3RyaW5nIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHBhcnNlXG5cdFx0XHRcdHBhcnNlZFVSTCA9IHBhcnNlVVJMKGAke2lucHV0fWApO1xuXHRcdFx0fVxuXHRcdFx0aW5wdXQgPSB7fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyc2VkVVJMID0gcGFyc2VVUkwoaW5wdXQudXJsKTtcblx0XHR9XG5cblx0XHRsZXQgbWV0aG9kID0gaW5pdC5tZXRob2QgfHwgaW5wdXQubWV0aG9kIHx8ICdHRVQnO1xuXHRcdG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0aWYgKChpbml0LmJvZHkgIT0gbnVsbCB8fCBpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwpICYmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5Jyk7XG5cdFx0fVxuXG5cdFx0bGV0IGlucHV0Qm9keSA9IGluaXQuYm9keSAhPSBudWxsID8gaW5pdC5ib2R5IDogaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsID8gY2xvbmUoaW5wdXQpIDogbnVsbDtcblxuXHRcdEJvZHkuY2FsbCh0aGlzLCBpbnB1dEJvZHksIHtcblx0XHRcdHRpbWVvdXQ6IGluaXQudGltZW91dCB8fCBpbnB1dC50aW1lb3V0IHx8IDAsXG5cdFx0XHRzaXplOiBpbml0LnNpemUgfHwgaW5wdXQuc2l6ZSB8fCAwXG5cdFx0fSk7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzIHx8IGlucHV0LmhlYWRlcnMgfHwge30pO1xuXG5cdFx0aWYgKGlucHV0Qm9keSAhPSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGlucHV0Qm9keSk7XG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0aGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgc2lnbmFsID0gaXNSZXF1ZXN0KGlucHV0KSA/IGlucHV0LnNpZ25hbCA6IG51bGw7XG5cdFx0aWYgKCdzaWduYWwnIGluIGluaXQpIHNpZ25hbCA9IGluaXQuc2lnbmFsO1xuXG5cdFx0aWYgKHNpZ25hbCAhPSBudWxsICYmICFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNpZ25hbCB0byBiZSBhbiBpbnN0YW5jZW9mIEFib3J0U2lnbmFsJyk7XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFMkMl0gPSB7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHRyZWRpcmVjdDogaW5pdC5yZWRpcmVjdCB8fCBpbnB1dC5yZWRpcmVjdCB8fCAnZm9sbG93Jyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRwYXJzZWRVUkwsXG5cdFx0XHRzaWduYWxcblx0XHR9O1xuXG5cdFx0Ly8gbm9kZS1mZXRjaC1vbmx5IG9wdGlvbnNcblx0XHR0aGlzLmZvbGxvdyA9IGluaXQuZm9sbG93ICE9PSB1bmRlZmluZWQgPyBpbml0LmZvbGxvdyA6IGlucHV0LmZvbGxvdyAhPT0gdW5kZWZpbmVkID8gaW5wdXQuZm9sbG93IDogMjA7XG5cdFx0dGhpcy5jb21wcmVzcyA9IGluaXQuY29tcHJlc3MgIT09IHVuZGVmaW5lZCA/IGluaXQuY29tcHJlc3MgOiBpbnB1dC5jb21wcmVzcyAhPT0gdW5kZWZpbmVkID8gaW5wdXQuY29tcHJlc3MgOiB0cnVlO1xuXHRcdHRoaXMuY291bnRlciA9IGluaXQuY291bnRlciB8fCBpbnB1dC5jb3VudGVyIHx8IDA7XG5cdFx0dGhpcy5hZ2VudCA9IGluaXQuYWdlbnQgfHwgaW5wdXQuYWdlbnQ7XG5cdH1cblxuXHRnZXQgbWV0aG9kKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5tZXRob2Q7XG5cdH1cblxuXHRnZXQgdXJsKCkge1xuXHRcdHJldHVybiBmb3JtYXRfdXJsKHRoaXNbSU5URVJOQUxTJDJdLnBhcnNlZFVSTCk7XG5cdH1cblxuXHRnZXQgaGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uaGVhZGVycztcblx0fVxuXG5cdGdldCByZWRpcmVjdCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0ucmVkaXJlY3Q7XG5cdH1cblxuXHRnZXQgc2lnbmFsKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5zaWduYWw7XG5cdH1cblxuXHQvKipcbiAgKiBDbG9uZSB0aGlzIHJlcXVlc3RcbiAgKlxuICAqIEByZXR1cm4gIFJlcXVlc3RcbiAgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpO1xuXHR9XG59XG5cbkJvZHkubWl4SW4oUmVxdWVzdC5wcm90b3R5cGUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ1JlcXVlc3QnLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuXHRtZXRob2Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRoZWFkZXJzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0cmVkaXJlY3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRjbG9uZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBSZXF1ZXN0IHRvIE5vZGUuanMgaHR0cCByZXF1ZXN0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICAgUmVxdWVzdCAgQSBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuICBPYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIGh0dHAucmVxdWVzdFxuICovXG5mdW5jdGlvbiBnZXROb2RlUmVxdWVzdE9wdGlvbnMocmVxdWVzdCkge1xuXHRjb25zdCBwYXJzZWRVUkwgPSByZXF1ZXN0W0lOVEVSTkFMUyQyXS5wYXJzZWRVUkw7XG5cdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXF1ZXN0W0lOVEVSTkFMUyQyXS5oZWFkZXJzKTtcblxuXHQvLyBmZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBCYXNpYyBmZXRjaFxuXHRpZiAoIXBhcnNlZFVSTC5wcm90b2NvbCB8fCAhcGFyc2VkVVJMLmhvc3RuYW1lKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT25seSBhYnNvbHV0ZSBVUkxzIGFyZSBzdXBwb3J0ZWQnKTtcblx0fVxuXG5cdGlmICghL15odHRwcz86JC8udGVzdChwYXJzZWRVUkwucHJvdG9jb2wpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT25seSBIVFRQKFMpIHByb3RvY29scyBhcmUgc3VwcG9ydGVkJyk7XG5cdH1cblxuXHRpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlICYmICFzdHJlYW1EZXN0cnVjdGlvblN1cHBvcnRlZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignQ2FuY2VsbGF0aW9uIG9mIHN0cmVhbWVkIHJlcXVlc3RzIHdpdGggQWJvcnRTaWduYWwgaXMgbm90IHN1cHBvcnRlZCBpbiBub2RlIDwgOCcpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXBzIDIuNC0yLjdcblx0bGV0IGNvbnRlbnRMZW5ndGhWYWx1ZSA9IG51bGw7XG5cdGlmIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJiAvXihQT1NUfFBVVCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XG5cdH1cblx0aWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG5cdFx0aWYgKHR5cGVvZiB0b3RhbEJ5dGVzID09PSAnbnVtYmVyJykge1xuXHRcdFx0Y29udGVudExlbmd0aFZhbHVlID0gU3RyaW5nKHRvdGFsQnl0ZXMpO1xuXHRcdH1cblx0fVxuXHRpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTFcblx0aWYgKCFoZWFkZXJzLmhhcygnVXNlci1BZ2VudCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ1VzZXItQWdlbnQnLCAnbm9kZS1mZXRjaC8xLjAgKCtodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gpJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjE1XG5cdGlmIChyZXF1ZXN0LmNvbXByZXNzICYmICFoZWFkZXJzLmhhcygnQWNjZXB0LUVuY29kaW5nJykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsZGVmbGF0ZScpO1xuXHR9XG5cblx0bGV0IGFnZW50ID0gcmVxdWVzdC5hZ2VudDtcblx0aWYgKHR5cGVvZiBhZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGFnZW50ID0gYWdlbnQocGFyc2VkVVJMKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDQuMlxuXHQvLyBjaHVua2VkIGVuY29kaW5nIGlzIGhhbmRsZWQgYnkgTm9kZS5qc1xuXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRVUkwsIHtcblx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdGhlYWRlcnM6IGV4cG9ydE5vZGVDb21wYXRpYmxlSGVhZGVycyhoZWFkZXJzKSxcblx0XHRhZ2VudFxuXHR9KTtcbn1cblxuLyoqXG4gKiBhYm9ydC1lcnJvci5qc1xuICpcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBBYm9ydEVycm9yIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgU3RyaW5nICAgICAgbWVzc2FnZSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG4gKiBAcmV0dXJuICBBYm9ydEVycm9yXG4gKi9cbmZ1bmN0aW9uIEFib3J0RXJyb3IobWVzc2FnZSkge1xuICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIHRoaXMudHlwZSA9ICdhYm9ydGVkJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAvLyBoaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xufVxuXG5BYm9ydEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkFib3J0RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJvcnRFcnJvcjtcbkFib3J0RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQWJvcnRFcnJvcic7XG5cbmNvbnN0IFVSTCQxID0gVXJsLlVSTCB8fCB3aGF0d2dVcmwuVVJMO1xuXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJQYXNzVGhyb3VnaFwiLCBcInJlc29sdmVcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBQYXNzVGhyb3VnaCQxID0gU3RyZWFtLlBhc3NUaHJvdWdoO1xuXG5jb25zdCBpc0RvbWFpbk9yU3ViZG9tYWluID0gZnVuY3Rpb24gaXNEb21haW5PclN1YmRvbWFpbihkZXN0aW5hdGlvbiwgb3JpZ2luYWwpIHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwkMShvcmlnaW5hbCkuaG9zdG5hbWU7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMJDEoZGVzdGluYXRpb24pLmhvc3RuYW1lO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0IHx8IG9yaWdbb3JpZy5sZW5ndGggLSBkZXN0Lmxlbmd0aCAtIDFdID09PSAnLicgJiYgb3JpZy5lbmRzV2l0aChkZXN0KTtcbn07XG5cbi8qKlxuICogaXNTYW1lUHJvdG9jb2wgcmVwb3J0cyB3aGV0aGVyIHRoZSB0d28gcHJvdmlkZWQgVVJMcyB1c2UgdGhlIHNhbWUgcHJvdG9jb2wuXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuY29uc3QgaXNTYW1lUHJvdG9jb2wgPSBmdW5jdGlvbiBpc1NhbWVQcm90b2NvbChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpIHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwkMShvcmlnaW5hbCkucHJvdG9jb2w7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMJDEoZGVzdGluYXRpb24pLnByb3RvY29sO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0O1xufTtcblxuLyoqXG4gKiBGZXRjaCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgIHVybCAgIEFic29sdXRlIHVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBPYmplY3QgICBvcHRzICBGZXRjaCBvcHRpb25zXG4gKiBAcmV0dXJuICBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGZldGNoKHVybCwgb3B0cykge1xuXG5cdC8vIGFsbG93IGN1c3RvbSBwcm9taXNlXG5cdGlmICghZmV0Y2guUHJvbWlzZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignbmF0aXZlIHByb21pc2UgbWlzc2luZywgc2V0IGZldGNoLlByb21pc2UgdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuXHR9XG5cblx0Qm9keS5Qcm9taXNlID0gZmV0Y2guUHJvbWlzZTtcblxuXHQvLyB3cmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdHJldHVybiBuZXcgZmV0Y2guUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0Ly8gYnVpbGQgcmVxdWVzdCBvYmplY3Rcblx0XHRjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBvcHRzKTtcblx0XHRjb25zdCBvcHRpb25zID0gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpO1xuXG5cdFx0Y29uc3Qgc2VuZCA9IChvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCkucmVxdWVzdDtcblx0XHRjb25zdCBzaWduYWwgPSByZXF1ZXN0LnNpZ25hbDtcblxuXHRcdGxldCByZXNwb25zZSA9IG51bGw7XG5cblx0XHRjb25zdCBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuXHRcdFx0bGV0IGVycm9yID0gbmV3IEFib3J0RXJyb3IoJ1RoZSB1c2VyIGFib3J0ZWQgYSByZXF1ZXN0LicpO1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdGRlc3Ryb3lTdHJlYW0ocmVxdWVzdC5ib2R5LCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5ib2R5KSByZXR1cm47XG5cdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdH07XG5cblx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFib3J0QW5kRmluYWxpemUgPSBmdW5jdGlvbiBhYm9ydEFuZEZpbmFsaXplKCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fTtcblxuXHRcdC8vIHNlbmQgcmVxdWVzdFxuXHRcdGNvbnN0IHJlcSA9IHNlbmQob3B0aW9ucyk7XG5cdFx0bGV0IHJlcVRpbWVvdXQ7XG5cblx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcblx0XHRcdHJlcS5hYm9ydCgpO1xuXHRcdFx0aWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHRjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0aWYgKHJlcXVlc3QudGltZW91dCkge1xuXHRcdFx0cmVxLm9uY2UoJ3NvY2tldCcsIGZ1bmN0aW9uIChzb2NrZXQpIHtcblx0XHRcdFx0cmVxVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbmV0d29yayB0aW1lb3V0IGF0OiAke3JlcXVlc3QudXJsfWAsICdyZXF1ZXN0LXRpbWVvdXQnKSk7XG5cdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0fSwgcmVxdWVzdC50aW1lb3V0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHJlcXVlc3QgdG8gJHtyZXF1ZXN0LnVybH0gZmFpbGVkLCByZWFzb246ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xuXG5cdFx0XHRpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRkZXN0cm95U3RyZWFtKHJlc3BvbnNlLmJvZHksIGVycik7XG5cdFx0XHR9XG5cblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fSk7XG5cblx0XHRmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyhyZXEsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRkZXN0cm95U3RyZWFtKHJlc3BvbnNlLmJvZHksIGVycik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAxOCAqL1xuXHRcdGlmIChwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3Vic3RyaW5nKDEpKSA8IDE0KSB7XG5cdFx0XHQvLyBCZWZvcmUgTm9kZS5qcyAxNCwgcGlwZWxpbmUoKSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycyBhbmQgZG9lcyBub3QgYWx3YXlzXG5cdFx0XHQvLyBwcm9wZXJseSBoYW5kbGUgd2hlbiB0aGUgc29ja2V0IGNsb3NlL2VuZCBldmVudHMgYXJlIG91dCBvZiBvcmRlci5cblx0XHRcdHJlcS5vbignc29ja2V0JywgZnVuY3Rpb24gKHMpIHtcblx0XHRcdFx0cy5hZGRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbiAoaGFkRXJyb3IpIHtcblx0XHRcdFx0XHQvLyBpZiBhIGRhdGEgbGlzdGVuZXIgaXMgc3RpbGwgcHJlc2VudCB3ZSBkaWRuJ3QgZW5kIGNsZWFubHlcblx0XHRcdFx0XHRjb25zdCBoYXNEYXRhTGlzdGVuZXIgPSBzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDA7XG5cblx0XHRcdFx0XHQvLyBpZiBlbmQgaGFwcGVuZWQgYmVmb3JlIGNsb3NlIGJ1dCB0aGUgc29ja2V0IGRpZG4ndCBlbWl0IGFuIGVycm9yLCBkbyBpdCBub3dcblx0XHRcdFx0XHRpZiAocmVzcG9uc2UgJiYgaGFzRGF0YUxpc3RlbmVyICYmICFoYWRFcnJvciAmJiAhKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGVyciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdFx0XHRlcnIuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXMpIHtcblx0XHRcdGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblxuXHRcdFx0Y29uc3QgaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnNMZW5pZW50KHJlcy5oZWFkZXJzKTtcblxuXHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDVcblx0XHRcdGlmIChmZXRjaC5pc1JlZGlyZWN0KHJlcy5zdGF0dXNDb2RlKSkge1xuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4yXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuM1xuXHRcdFx0XHRsZXQgbG9jYXRpb25VUkwgPSBudWxsO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxvY2F0aW9uVVJMID0gbG9jYXRpb24gPT09IG51bGwgPyBudWxsIDogbmV3IFVSTCQxKGxvY2F0aW9uLCByZXF1ZXN0LnVybCkudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0Ly8gZXJyb3IgaGVyZSBjYW4gb25seSBiZSBpbnZhbGlkIFVSTCBpbiBMb2NhdGlvbjogaGVhZGVyXG5cdFx0XHRcdFx0Ly8gZG8gbm90IHRocm93IHdoZW4gb3B0aW9ucy5yZWRpcmVjdCA9PSBtYW51YWxcblx0XHRcdFx0XHQvLyBsZXQgdGhlIHVzZXIgZXh0cmFjdCB0aGUgZXJyb3JuZW91cyByZWRpcmVjdCBVUkxcblx0XHRcdFx0XHRpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke2xvY2F0aW9ufWAsICdpbnZhbGlkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIG5vZGUtZmV0Y2gtc3BlY2lmaWMgc3RlcDogbWFrZSBtYW51YWwgcmVkaXJlY3QgYSBiaXQgZWFzaWVyIHRvIHVzZSBieSBzZXR0aW5nIHRoZSBMb2NhdGlvbiBoZWFkZXIgdmFsdWUgdG8gdGhlIHJlc29sdmVkIFVSTC5cblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHQvLyBoYW5kbGUgY29ycnVwdGVkIGhlYWRlclxuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGhlYWRlcnMuc2V0KCdMb2NhdGlvbicsIGxvY2F0aW9uVVJMKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vZGVqcyBzZXJ2ZXIgcHJldmVudCBpbnZhbGlkIHJlc3BvbnNlIGhlYWRlcnMsIHdlIGNhbid0IHRlc3QgdGhpcyB0aHJvdWdoIG5vcm1hbCByZXF1ZXN0XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZvbGxvdyc6XG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMlxuXHRcdFx0XHRcdFx0aWYgKGxvY2F0aW9uVVJMID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNVxuXHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QuY291bnRlciA+PSByZXF1ZXN0LmZvbGxvdykge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYG1heGltdW0gcmVkaXJlY3QgcmVhY2hlZCBhdDogJHtyZXF1ZXN0LnVybH1gLCAnbWF4LXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA2IChjb3VudGVyIGluY3JlbWVudClcblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIG5ldyBSZXF1ZXN0IG9iamVjdC5cblx0XHRcdFx0XHRcdGNvbnN0IHJlcXVlc3RPcHRzID0ge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxuXHRcdFx0XHRcdFx0XHRmb2xsb3c6IHJlcXVlc3QuZm9sbG93LFxuXHRcdFx0XHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXIgKyAxLFxuXHRcdFx0XHRcdFx0XHRhZ2VudDogcmVxdWVzdC5hZ2VudCxcblx0XHRcdFx0XHRcdFx0Y29tcHJlc3M6IHJlcXVlc3QuY29tcHJlc3MsXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHJlcXVlc3QuYm9keSxcblx0XHRcdFx0XHRcdFx0c2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcblx0XHRcdFx0XHRcdFx0dGltZW91dDogcmVxdWVzdC50aW1lb3V0LFxuXHRcdFx0XHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemVcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGlmICghaXNEb21haW5PclN1YmRvbWFpbihyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpIHx8ICFpc1NhbWVQcm90b2NvbChyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiBbJ2F1dGhvcml6YXRpb24nLCAnd3d3LWF1dGhlbnRpY2F0ZScsICdjb29raWUnLCAnY29va2llMiddKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuaGVhZGVycy5kZWxldGUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDlcblx0XHRcdFx0XHRcdGlmIChyZXMuc3RhdHVzQ29kZSAhPT0gMzAzICYmIHJlcXVlc3QuYm9keSAmJiBnZXRUb3RhbEJ5dGVzKHJlcXVlc3QpID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcignQ2Fubm90IGZvbGxvdyByZWRpcmVjdCB3aXRoIGJvZHkgYmVpbmcgYSByZWFkYWJsZSBzdHJlYW0nLCAndW5zdXBwb3J0ZWQtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDExXG5cdFx0XHRcdFx0XHRpZiAocmVzLnN0YXR1c0NvZGUgPT09IDMwMyB8fCAocmVzLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRzLm1ldGhvZCA9ICdHRVQnO1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5ib2R5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5oZWFkZXJzLmRlbGV0ZSgnY29udGVudC1sZW5ndGgnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDE1XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZldGNoKG5ldyBSZXF1ZXN0KGxvY2F0aW9uVVJMLCByZXF1ZXN0T3B0cykpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJlcGFyZSByZXNwb25zZVxuXHRcdFx0cmVzLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9KTtcblx0XHRcdGxldCBib2R5ID0gcmVzLnBpcGUobmV3IFBhc3NUaHJvdWdoJDEoKSk7XG5cblx0XHRcdGNvbnN0IHJlc3BvbnNlX29wdGlvbnMgPSB7XG5cdFx0XHRcdHVybDogcmVxdWVzdC51cmwsXG5cdFx0XHRcdHN0YXR1czogcmVzLnN0YXR1c0NvZGUsXG5cdFx0XHRcdHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNNZXNzYWdlLFxuXHRcdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dCxcblx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuM1xuXHRcdFx0Y29uc3QgY29kaW5ncyA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUVuY29kaW5nJyk7XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS40OiBoYW5kbGUgY29udGVudCBjb2RpbmdzXG5cblx0XHRcdC8vIGluIGZvbGxvd2luZyBzY2VuYXJpb3Mgd2UgaWdub3JlIGNvbXByZXNzaW9uIHN1cHBvcnRcblx0XHRcdC8vIDEuIGNvbXByZXNzaW9uIHN1cHBvcnQgaXMgZGlzYWJsZWRcblx0XHRcdC8vIDIuIEhFQUQgcmVxdWVzdFxuXHRcdFx0Ly8gMy4gbm8gQ29udGVudC1FbmNvZGluZyBoZWFkZXJcblx0XHRcdC8vIDQuIG5vIGNvbnRlbnQgcmVzcG9uc2UgKDIwNClcblx0XHRcdC8vIDUuIGNvbnRlbnQgbm90IG1vZGlmaWVkIHJlc3BvbnNlICgzMDQpXG5cdFx0XHRpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fCBjb2RpbmdzID09PSBudWxsIHx8IHJlcy5zdGF0dXNDb2RlID09PSAyMDQgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIE5vZGUgdjYrXG5cdFx0XHQvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcblx0XHRcdC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuXHRcdFx0Ly8gYnkgY29tbW9uIGJyb3dzZXJzLlxuXHRcdFx0Ly8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cblx0XHRcdGNvbnN0IHpsaWJPcHRpb25zID0ge1xuXHRcdFx0XHRmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG5cdFx0XHRcdGZpbmlzaEZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZm9yIGd6aXBcblx0XHRcdGlmIChjb2RpbmdzID09ICdnemlwJyB8fCBjb2RpbmdzID09ICd4LWd6aXAnKSB7XG5cdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVHdW56aXAoemxpYk9wdGlvbnMpKTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBkZWZsYXRlXG5cdFx0XHRpZiAoY29kaW5ncyA9PSAnZGVmbGF0ZScgfHwgY29kaW5ncyA9PSAneC1kZWZsYXRlJykge1xuXHRcdFx0XHQvLyBoYW5kbGUgdGhlIGluZmFtb3VzIHJhdyBkZWZsYXRlIHJlc3BvbnNlIGZyb20gb2xkIHNlcnZlcnNcblx0XHRcdFx0Ly8gYSBoYWNrIGZvciBvbGQgSUlTIGFuZCBBcGFjaGUgc2VydmVyc1xuXHRcdFx0XHRjb25zdCByYXcgPSByZXMucGlwZShuZXcgUGFzc1Rocm91Z2gkMSgpKTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcblx0XHRcdFx0XHQvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNzUxOTgyOFxuXHRcdFx0XHRcdGlmICgoY2h1bmtbMF0gJiAweDBGKSA9PT0gMHgwOCkge1xuXHRcdFx0XHRcdFx0Ym9keSA9IGJvZHkucGlwZSh6bGliLmNyZWF0ZUluZmxhdGUoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVJbmZsYXRlUmF3KCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIHNvbWUgb2xkIElJUyBzZXJ2ZXJzIHJldHVybiB6ZXJvLWxlbmd0aCBPSyBkZWZsYXRlIHJlc3BvbnNlcywgc28gJ2RhdGEnIGlzIG5ldmVyIGVtaXR0ZWQuXG5cdFx0XHRcdFx0aWYgKCFyZXNwb25zZSkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBiclxuXHRcdFx0aWYgKGNvZGluZ3MgPT0gJ2JyJyAmJiB0eXBlb2YgemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCkpO1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xuXHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0fSk7XG5cblx0XHR3cml0ZVRvU3RyZWFtKHJlcSwgcmVxdWVzdCk7XG5cdH0pO1xufVxuZnVuY3Rpb24gZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdCwgZXJyb3JDYWxsYmFjaykge1xuXHRsZXQgc29ja2V0O1xuXG5cdHJlcXVlc3Qub24oJ3NvY2tldCcsIGZ1bmN0aW9uIChzKSB7XG5cdFx0c29ja2V0ID0gcztcblx0fSk7XG5cblx0cmVxdWVzdC5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRjb25zdCBoZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcblxuXHRcdGlmIChoZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddID09PSAnY2h1bmtlZCcgJiYgIWhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHtcblx0XHRcdHJlc3BvbnNlLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKGhhZEVycm9yKSB7XG5cdFx0XHRcdC8vIHRlc3RzIGZvciBzb2NrZXQgcHJlc2VuY2UsIGFzIGluIHNvbWUgc2l0dWF0aW9ucyB0aGVcblx0XHRcdFx0Ly8gdGhlICdzb2NrZXQnIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWQgZm9yIHRoZSByZXF1ZXN0XG5cdFx0XHRcdC8vIChoYXBwZW5zIGluIGRlbm8pLCBhdm9pZHMgYFR5cGVFcnJvcmBcblx0XHRcdFx0Ly8gaWYgYSBkYXRhIGxpc3RlbmVyIGlzIHN0aWxsIHByZXNlbnQgd2UgZGlkbid0IGVuZCBjbGVhbmx5XG5cdFx0XHRcdGNvbnN0IGhhc0RhdGFMaXN0ZW5lciA9IHNvY2tldCAmJiBzb2NrZXQubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMDtcblxuXHRcdFx0XHRpZiAoaGFzRGF0YUxpc3RlbmVyICYmICFoYWRFcnJvcikge1xuXHRcdFx0XHRcdGNvbnN0IGVyciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdFx0ZXJyLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveVN0cmVhbShzdHJlYW0sIGVycikge1xuXHRpZiAoc3RyZWFtLmRlc3Ryb3kpIHtcblx0XHRzdHJlYW0uZGVzdHJveShlcnIpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIG5vZGUgPCA4XG5cdFx0c3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0XHRzdHJlYW0uZW5kKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWRpcmVjdCBjb2RlIG1hdGNoaW5nXG4gKlxuICogQHBhcmFtICAgTnVtYmVyICAgY29kZSAgU3RhdHVzIGNvZGVcbiAqIEByZXR1cm4gIEJvb2xlYW5cbiAqL1xuZmV0Y2guaXNSZWRpcmVjdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG5cdHJldHVybiBjb2RlID09PSAzMDEgfHwgY29kZSA9PT0gMzAyIHx8IGNvZGUgPT09IDMwMyB8fCBjb2RlID09PSAzMDcgfHwgY29kZSA9PT0gMzA4O1xufTtcblxuLy8gZXhwb3NlIFByb21pc2VcbmZldGNoLlByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcblxuZXhwb3J0IGRlZmF1bHQgZmV0Y2g7XG5leHBvcnQgeyBIZWFkZXJzLCBSZXF1ZXN0LCBSZXNwb25zZSwgRmV0Y2hFcnJvciwgQWJvcnRFcnJvciB9O1xuIl0sIm5hbWVzIjpbIlN0cmVhbSIsImh0dHAiLCJVcmwiLCJ3aGF0d2dVcmwiLCJodHRwcyIsInpsaWIiLCJSZWFkYWJsZSIsIkJVRkZFUiIsIlN5bWJvbCIsIlRZUEUiLCJCbG9iIiwiY29uc3RydWN0b3IiLCJibG9iUGFydHMiLCJhcmd1bWVudHMiLCJvcHRpb25zIiwiYnVmZmVycyIsInNpemUiLCJhIiwibGVuZ3RoIiwiTnVtYmVyIiwiaSIsImVsZW1lbnQiLCJidWZmZXIiLCJCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb20iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlN0cmluZyIsInB1c2giLCJjb25jYXQiLCJ0eXBlIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwidGV4dCIsIlByb21pc2UiLCJyZXNvbHZlIiwidG9TdHJpbmciLCJhcnJheUJ1ZmZlciIsImJ1ZiIsImFiIiwic2xpY2UiLCJzdHJlYW0iLCJyZWFkYWJsZSIsIl9yZWFkIiwic3RhcnQiLCJlbmQiLCJyZWxhdGl2ZVN0YXJ0IiwicmVsYXRpdmVFbmQiLCJNYXRoIiwibWF4IiwibWluIiwic3BhbiIsInNsaWNlZEJ1ZmZlciIsImJsb2IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiRmV0Y2hFcnJvciIsIm1lc3NhZ2UiLCJzeXN0ZW1FcnJvciIsIkVycm9yIiwiY2FsbCIsImNvZGUiLCJlcnJubyIsImNhcHR1cmVTdGFja1RyYWNlIiwiY3JlYXRlIiwibmFtZSIsImNvbnZlcnQiLCJyZXF1aXJlIiwiZSIsIklOVEVSTkFMUyIsIlBhc3NUaHJvdWdoIiwiQm9keSIsImJvZHkiLCJfdGhpcyIsIl9yZWYiLCJfcmVmJHNpemUiLCJfcmVmJHRpbWVvdXQiLCJ0aW1lb3V0IiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJpc0Jsb2IiLCJpc0J1ZmZlciIsImRpc3R1cmJlZCIsImVycm9yIiwib24iLCJlcnIiLCJ1cmwiLCJib2R5VXNlZCIsImNvbnN1bWVCb2R5IiwidGhlbiIsImN0IiwiaGVhZGVycyIsImdldCIsImFzc2lnbiIsImpzb24iLCJfdGhpczIiLCJKU09OIiwicGFyc2UiLCJyZWplY3QiLCJ0ZXh0Q29udmVydGVkIiwiX3RoaXMzIiwiY29udmVydEJvZHkiLCJtaXhJbiIsInByb3RvIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfdGhpczQiLCJUeXBlRXJyb3IiLCJhbGxvYyIsImFjY3VtIiwiYWNjdW1CeXRlcyIsImFib3J0IiwicmVzVGltZW91dCIsInNldFRpbWVvdXQiLCJjaHVuayIsImNsZWFyVGltZW91dCIsImNoYXJzZXQiLCJyZXMiLCJzdHIiLCJleGVjIiwicG9wIiwib2JqIiwiYXBwZW5kIiwiZGVsZXRlIiwiZ2V0QWxsIiwiaGFzIiwic2V0Iiwic29ydCIsImNsb25lIiwiaW5zdGFuY2UiLCJwMSIsInAyIiwiZ2V0Qm91bmRhcnkiLCJwaXBlIiwiZXh0cmFjdENvbnRlbnRUeXBlIiwiZ2V0VG90YWxCeXRlcyIsImdldExlbmd0aFN5bmMiLCJfbGVuZ3RoUmV0cmlldmVycyIsImhhc0tub3duTGVuZ3RoIiwid3JpdGVUb1N0cmVhbSIsImRlc3QiLCJ3cml0ZSIsImdsb2JhbCIsImludmFsaWRUb2tlblJlZ2V4IiwiaW52YWxpZEhlYWRlckNoYXJSZWdleCIsInZhbGlkYXRlTmFtZSIsInZhbGlkYXRlVmFsdWUiLCJmaW5kIiwibWFwIiwia2V5IiwiTUFQIiwiSGVhZGVycyIsImluaXQiLCJyYXdIZWFkZXJzIiwicmF3IiwiaGVhZGVyTmFtZXMiLCJrZXlzIiwiaGVhZGVyTmFtZSIsIm1ldGhvZCIsIml0ZXJhdG9yIiwicGFpcnMiLCJwYWlyIiwiQXJyYXkiLCJqb2luIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwidGhpc0FyZyIsImdldEhlYWRlcnMiLCJfcGFpcnMkaSIsImNyZWF0ZUhlYWRlcnNJdGVyYXRvciIsInZhbHVlcyIsImVudHJpZXMiLCJraW5kIiwiayIsIklOVEVSTkFMIiwidGFyZ2V0IiwiSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlIiwiaW5kZXgiLCJzZXRQcm90b3R5cGVPZiIsIm5leHQiLCJnZXRQcm90b3R5cGVPZiIsIl9JTlRFUk5BTCIsImxlbiIsImRvbmUiLCJleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMiLCJfX3Byb3RvX18iLCJob3N0SGVhZGVyS2V5IiwiY3JlYXRlSGVhZGVyc0xlbmllbnQiLCJpc0FycmF5IiwidmFsIiwiSU5URVJOQUxTJDEiLCJTVEFUVVNfQ09ERVMiLCJSZXNwb25zZSIsIm9wdHMiLCJzdGF0dXMiLCJjb250ZW50VHlwZSIsInN0YXR1c1RleHQiLCJjb3VudGVyIiwib2siLCJyZWRpcmVjdGVkIiwiSU5URVJOQUxTJDIiLCJVUkwiLCJwYXJzZV91cmwiLCJmb3JtYXRfdXJsIiwiZm9ybWF0IiwicGFyc2VVUkwiLCJ1cmxTdHIiLCJzdHJlYW1EZXN0cnVjdGlvblN1cHBvcnRlZCIsImlzUmVxdWVzdCIsImlucHV0IiwiaXNBYm9ydFNpZ25hbCIsInNpZ25hbCIsIlJlcXVlc3QiLCJwYXJzZWRVUkwiLCJocmVmIiwidG9VcHBlckNhc2UiLCJpbnB1dEJvZHkiLCJyZWRpcmVjdCIsImZvbGxvdyIsImNvbXByZXNzIiwiYWdlbnQiLCJnZXROb2RlUmVxdWVzdE9wdGlvbnMiLCJyZXF1ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsImNvbnRlbnRMZW5ndGhWYWx1ZSIsInRvdGFsQnl0ZXMiLCJBYm9ydEVycm9yIiwiVVJMJDEiLCJQYXNzVGhyb3VnaCQxIiwiaXNEb21haW5PclN1YmRvbWFpbiIsImRlc3RpbmF0aW9uIiwib3JpZ2luYWwiLCJvcmlnIiwiZW5kc1dpdGgiLCJpc1NhbWVQcm90b2NvbCIsImZldGNoIiwic2VuZCIsInJlc3BvbnNlIiwiZGVzdHJveVN0cmVhbSIsImVtaXQiLCJhYm9ydGVkIiwiYWJvcnRBbmRGaW5hbGl6ZSIsImZpbmFsaXplIiwicmVxIiwicmVxVGltZW91dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25jZSIsInNvY2tldCIsImZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwidmVyc2lvbiIsInN1YnN0cmluZyIsInMiLCJhZGRMaXN0ZW5lciIsImhhZEVycm9yIiwiaGFzRGF0YUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImlzUmVkaXJlY3QiLCJzdGF0dXNDb2RlIiwibG9jYXRpb24iLCJsb2NhdGlvblVSTCIsInJlcXVlc3RPcHRzIiwicmVzcG9uc2Vfb3B0aW9ucyIsInN0YXR1c01lc3NhZ2UiLCJjb2RpbmdzIiwiemxpYk9wdGlvbnMiLCJmbHVzaCIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlR3VuemlwIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJjcmVhdGVCcm90bGlEZWNvbXByZXNzIiwiZXJyb3JDYWxsYmFjayIsImRlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch/lib/index.mjs\n");

/***/ })

};
;